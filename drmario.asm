################# CSC258 Assembly Final Project ###################
# This file contains our implementation of Dr Mario.
#
# Student 1: Vennise Ho 1009972923
#
# We assert that the code submitted here is entirely our own 
# creation, and will indicate otherwise when it is not.
#
######################## Bitmap Display Configuration ########################
# - Unit width in pixels:       8
# - Unit height in pixels:      8
# - Display width in pixels:    256
# - Display height in pixels:   256
# - Base Address for Display:   0x10008000 ($gp)
##############################################################################
    .data
##############################################################################
# Immutable Data
##############################################################################
# The address of the bitmap display. Don't forget to connect it!
ADDR_DSPL:
    .word 0x10008000
# The address of the keyboard. Don't forget to connect it!
ADDR_KBRD:
    .word 0xffff0000

red:        .word 0xff0000
yellow:     .word 0xffff00
blue:       .word 0x00ffff
white:      .word 0xffffff
black:      .word 0x000000

a:          .word 0x61
d:          .word 0x64
w:          .word 0x77
s:          .word 0x73
q:          .word 0x71
n:          .word 0x6e
p:          .word 0x70
enter:      .word 0xa

init_x1:     .word 3
init_y1:     .word 0
init_x2:     .word 4
init_y2:     .word 0

game_board_offset:     .word 1968

# music arrays
times: .word 0, 0, 250, 250, 250, 500, 500, 500, 500, 750, 1000, 1000, 1000, 1000, 1125, 1250, 1500, 1500, 1500, 1500, 1750, 2000, 2000, 2000, 2000, 2250, 2500, 2500, 2500, 2500, 2750, 2750, 2750, 3000, 3000, 3250, 3500, 3500, 3500, 4000, 4250, 4250, 4250, 4500, 4500, 4500, 4500, 4750, 5000, 5000, 5000, 5000, 5125, 5250, 5500, 5500, 5500, 5500, 5750, 6000, 6000, 6000, 6250, 6500, 6500, 6875, 7000, 7125, 7500, 7500, 7500, 7500, 7625, 7625, 7750, 7750, 7875, 8000, 8000, 8000, 8000, 8000, 8000, 8250, 8250, 8250, 8250, 8500, 8500, 8500, 8500, 8500, 8750, 8750, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9125, 9250, 9250, 9500, 9500, 9500, 9500, 9500, 9750, 9750, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10250, 10250, 10500, 10500, 10500, 10500, 10500, 10750, 10750, 10750, 10750, 11000, 11000, 11000, 11000, 11000, 11250, 11500, 11500, 11500, 11500, 11750, 12000, 12000, 12000, 12000, 12250, 12250, 12250, 12250, 12500, 12500, 12500, 12500, 12500, 12750, 12750, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13125, 13250, 13250, 13500, 13500, 13500, 13500, 13500, 13750, 13750, 14000, 14000, 14000, 14000, 14000, 14000, 14000, 14250, 14250, 14500, 14500, 14500, 14500, 14500, 14750, 14750, 14750, 14750, 15000, 15000, 15000, 15000, 15000, 15250, 15500, 15500, 15500, 15500, 15750, 16000, 16000, 16000, 16000, 16000, 16250, 16250, 16250, 16250, 16500, 16500, 16500, 16500, 16500, 16750, 16750, 17000, 17000, 17000, 17000, 17000, 17000, 17000, 17125, 17250, 17250, 17500, 17500, 17500, 17500, 17500, 17750, 17750, 18000, 18000, 18000, 18000, 18000, 18000, 18000, 18250, 18250, 18500, 18500, 18500, 18500, 18500, 18750, 18750, 18750, 18750, 19000, 19000, 19000, 19000, 19000, 19250, 19500, 19500, 19500, 19500, 19750, 20000, 20000, 20000, 20000, 20250, 20250, 20250, 20250, 20500, 20500, 20500, 20500, 20500, 20750, 20750, 21000, 21000, 21000, 21000, 21000, 21000, 21000, 21125, 21250, 21250, 21500, 21500, 21500, 21500, 21500, 21750, 21750, 22000, 22000, 22000, 22000, 22000, 22000, 22125, 22250, 22250, 22250, 22375, 22375, 22500, 22500, 22500, 22500, 22500, 22500, 22625, 22625, 22750, 22750, 22750, 22875, 22875, 23000, 23000, 23000, 23000, 23000, 23000, 23000, 23125, 23125, 23125, 23250, 23250, 23250, 23250, 23375, 23375, 23375, 23500, 23500, 23500, 23500, 24000, 24000, 24000, 24000, 24000, 24250, 24250, 24250, 24500, 24500, 24500, 24500, 24500, 24500, 24750, 24750, 24750, 25000, 25000, 25000, 25000, 25000, 25000, 25125, 25250, 25250, 25500, 25500, 25500, 25500, 25500, 25750, 25750, 26000, 26000, 26000, 26000, 26000, 26000, 26250, 26250, 26250, 26500, 26500, 26500, 26500, 26500, 26500, 26750, 26750, 26750, 27000, 27000, 27000, 27000, 27000, 27000, 27250, 27500, 27500, 27500, 27500, 27750, 28000, 28000, 28000, 28000, 28250, 28250, 28250, 28500, 28500, 28500, 28500, 28500, 28500, 28750, 28750, 28750, 29000, 29000, 29000, 29000, 29000, 29000, 29125, 29250, 29250, 29500, 29500, 29500, 29500, 29500, 29500, 29500, 29750, 29750, 29750, 30000, 30000, 30000, 30000, 30000, 30000, 30250, 30250, 30500, 30500, 30500, 30500, 30500, 30750, 30750, 31000, 31000, 31000, 31000, 31000, 31250, 31500, 31500, 31500, 31500, 31750, 32000, 32000, 32000, 32000, 32000, 32250, 32250, 32250, 32375, 32500, 32500, 32500, 32500, 32500, 32500, 32750, 32750, 32750, 33000, 33000, 33000, 33000, 33000, 33000, 33125, 33250, 33250, 33500, 33500, 33500, 33500, 33500, 33750, 33750, 34000, 34000, 34000, 34000, 34000, 34000, 34250, 34250, 34250, 34500, 34500, 34500, 34500, 34500, 34500, 34750, 34750, 34750, 35000, 35000, 35000, 35000, 35000, 35000, 35250, 35250, 35500, 35500, 35500, 35500, 35750, 36000, 36000, 36000, 36000, 36250, 36250, 36250, 36500, 36500, 36500, 36500, 36500, 36500, 36750, 36750, 36750, 37000, 37000, 37000, 37000, 37000, 37000, 37125, 37250, 37250, 37500, 37500, 37500, 37500, 37500, 37500, 37750, 37750, 37750, 38000, 38000, 38000, 38000, 38000, 38000, 38250, 38250, 38250, 38500, 38500, 38500, 38500, 38500, 38750, 38750, 38750, 38750, 39000, 39000, 39000, 39000, 39000, 39125, 39125, 39250, 39250, 39250, 39500, 39500, 39500, 40000, 40000, 40000, 40000, 40000, 40000, 40000, 40125, 40250, 40250, 40375, 40500, 40500, 40500, 40500, 40500, 40625, 40750, 40750, 40875, 41000, 41000, 41000, 41125, 41250, 41250, 41375, 41500, 41500, 41500, 41500, 41500, 41625, 41750, 41750, 41875, 42000, 42000, 42000, 42000, 42000, 42000, 42125, 42250, 42250, 42375, 42500, 42500, 42500, 42500, 42500, 42625, 42750, 42750, 42875, 43000, 43000, 43000, 43125, 43250, 43250, 43375, 43500, 43500, 43500, 43500, 43500, 43625, 43750, 43750, 43875, 44000, 44000, 44000, 44000, 44000, 44000, 44000, 44125, 44250, 44250, 44375, 44500, 44500, 44500, 44500, 44500, 44625, 44750, 44750, 44875, 45000, 45000, 45000, 45000, 45125, 45250, 45250, 45375, 45500, 45500, 45500, 45500, 45500, 45625, 45750, 45750, 45875, 46000, 46000, 46000, 46000, 46000, 46000, 46000, 46125, 46250, 46250, 46250, 46375, 46500, 46500, 46500, 46500, 46625, 46750, 46750, 46750, 46875, 46875, 47000, 47000, 47000, 47000, 47125, 47125, 47250, 47250, 47250, 47375, 47375, 47500, 47500, 47500, 47500, 47500, 47500, 47500, 48000, 48000, 48000, 48000, 48000, 48250, 48250, 48250, 48250, 48500, 48500, 48500, 48500, 48500, 48500, 48750, 48750, 48750, 48750, 49000, 49000, 49000, 49000, 49000, 49000, 49000, 49250, 49500, 49500, 49500, 49500, 49500, 49750, 49750, 50000, 50000, 50000, 50000, 50000, 50000, 50000, 50250, 50250, 50250, 50500, 50500, 50500, 50500, 50500, 50500, 50750, 50750, 50750, 50750, 50750, 50750, 51000, 51000, 51000, 51000, 51000, 52000, 52000, 52000, 52000, 52000, 52250, 52250, 52250, 52250, 52500, 52500, 52500, 52500, 52500, 52500, 52750, 52750, 52750, 52750, 53000, 53000, 53000, 53000, 53000, 53000, 53000, 53250, 53500, 53500, 53500, 53500, 53500, 53750, 53750, 54000, 54000, 54000, 54000, 54000, 54000, 54000, 54250, 54250, 54250, 54500, 54500, 54500, 54500, 54500, 54500, 54750, 54750, 54750, 54750, 54750, 54750, 55000, 55000, 55000, 55000, 55000, 56000, 56000, 56000, 56000, 56000, 56250, 56250, 56250, 56250, 56500, 56500, 56500, 56500, 56500, 56500, 56750, 56750, 56750, 56750, 56750, 57000, 57000, 57000, 57000, 57000, 57000, 57000, 57250, 57500, 57500, 57500, 57500, 57500, 57750, 57750, 58000, 58000, 58000, 58000, 58000, 58000, 58000, 58250, 58250, 58250, 58500, 58500, 58500, 58500, 58500, 58500, 58750, 58750, 58750, 58750, 58750, 58750, 59000, 59000, 59000, 59000, 59000, 60000, 60000, 60000, 60000, 60000, 60250, 60250, 60250, 60250, 60500, 60500, 60500, 60500, 60500, 60500, 60750, 60750, 60750, 60750, 60750, 61000, 61000, 61000, 61000, 61000, 61000, 61000, 61250, 61500, 61500, 61500, 61500, 61500, 61750, 61750, 62000, 62000, 62000, 62000, 62000, 62000, 62000, 62250, 62250, 62250, 62500, 62500, 62500, 62500, 62500, 62500, 62750, 62750, 62750, 62750, 62750, 62750, 63000, 63000, 63000, 63000, 63000, 64000, 64000, 64000, 64000, 64250, 64250, 64250, 64500, 64500, 64500, 64500, 64750, 65000, 65000, 65000, 65000, 65000, 65000, 65250, 65500, 65500, 65500, 65500, 65750, 66000, 66000, 66000, 66000, 66000, 66000, 66250, 66500, 66500, 66500, 66500, 66750, 66750, 66750, 66750, 66750, 66750, 67000, 67500, 67500, 67500, 67500, 67625, 68000, 68000, 68000, 68000, 68250, 68250, 68250, 68500, 68500, 68500, 68500, 68750, 69000, 69000, 69000, 69000, 69000, 69000, 69250, 69500, 69500, 69500, 69500, 69750, 70000, 70000, 70000, 70000, 70000, 70000, 70250, 70500, 70500, 70500, 70500, 70625, 70625, 70750, 70750, 70750, 70750, 70750, 70875, 70875, 70875, 70875, 71125, 71125, 71250, 71375, 71500, 71500, 71500, 71500, 71500, 71625, 71625, 71625, 71625, 71750, 71750, 71750, 71875, 71875, 72000, 72000, 72000, 72000, 72000, 72125, 72250, 72250, 72250, 72250, 72500, 72500, 72500, 72500, 72500, 72750, 72750, 73000, 73000, 73000, 73000, 73000, 73000, 73000, 73250, 73250, 73500, 73500, 73500, 73500, 73500, 73750, 73750, 74000, 74000, 74000, 74000, 74000, 74000, 74000, 74125, 74250, 74250, 74500, 74500, 74500, 74500, 74500, 74750, 74750, 74750, 74750, 75000, 75000, 75000, 75000, 75000, 75250, 75250, 75500, 75500, 75500, 75500, 75500, 75500, 75500, 75750, 75750, 76000, 76000, 76000, 76000, 76000, 76125, 76250, 76250, 76250, 76250, 76500, 76500, 76500, 76500, 76500, 76750, 76750, 77000, 77000, 77000, 77000, 77000, 77000, 77000, 77250, 77250, 77500, 77500, 77500, 77500, 77500, 77750, 77750, 77750, 78000, 78000, 78000, 78000, 78000, 78000, 78000, 78250, 78250, 78500, 78500, 78500, 78500, 78750, 78750, 78750, 78750, 78750, 78750, 78750, 80000, 80000, 80000, 80000, 80000, 80000, 80000, 80000, 80125, 80125, 80125, 80125, 80250, 80250, 80250, 80375, 80375, 80500, 80500, 80500, 80500, 80500, 80500, 80625, 80625, 80625, 80625, 80750, 80750, 80750, 80875, 80875, 81000, 81000, 81000, 81000, 81000, 81000, 81125, 81125, 81250, 81250, 81250, 81375, 81500, 81500, 81500, 81500, 81500, 81500, 81500, 81500, 81625, 81750, 81750, 81750, 81875, 81875, 82000, 82000, 82000, 82000, 82000, 82000, 82000, 82000, 82125, 82250, 82250, 82250, 82250, 82250, 82250, 82375, 82375, 82500, 82500, 82500, 82500, 82500, 82500, 82500, 82500, 82625, 82625, 82625, 82750, 82750, 82750, 82750, 82750, 82875, 82875, 83000, 83000, 83125, 83250, 83250, 83250, 83250, 83250, 83250, 83375, 83375, 83375, 83375, 83375, 83500, 83500, 83500, 83625, 83625, 83625, 83625, 83625, 83750, 83750, 83875, 83875, 83875, 83875, 83875, 84000, 84000, 84000, 84000, 84000, 84000, 84000, 84000, 84125, 84125, 84125, 84250, 84250, 84250, 84375, 84375, 84500, 84500, 84500, 84500, 84500, 84500, 84500, 84625, 84625, 84625, 84750, 84750, 84875, 85000, 85000, 85000, 85000, 85000, 85125, 85125, 85250, 85250, 85250, 85375, 85500, 85500, 85500, 85500, 85500, 85500, 85500, 85500, 85625, 85750, 85750, 85750, 85875, 85875, 86000, 86000, 86000, 86000, 86000, 86000, 86000, 86125, 86250, 86250, 86250, 86250, 86250, 86250, 86375, 86500, 86500, 86500, 86500, 86500, 86500, 86500, 86500, 86625, 86625, 86625, 86750, 86750, 86750, 86750, 86875, 86875, 86875, 86875, 87000, 87000, 87125, 87250, 87250, 87250, 87250, 87250, 87250, 87375, 87375, 87375, 87375, 87375, 87500, 87500, 87500, 87625, 87625, 87625, 87625, 87625, 87750, 87750, 87875, 87875, 87875, 87875, 87875, 88000, 88000, 88000, 88000, 88000, 88000, 88000, 88000, 88125, 88125, 88125, 88125, 88250, 88250, 88375, 88375, 88500, 88500, 88500, 88500, 88500, 88625, 88625, 88625, 88625, 88750, 88750, 88875, 88875, 89000, 89000, 89000, 89000, 89000, 89000, 89125, 89125, 89250, 89250, 89250, 89500, 89500, 89500, 89500, 89500, 89500, 89500, 89500, 89750, 89750, 89875, 89875, 90000, 90000, 90000, 90000, 90000, 90000, 90000, 90000, 90125, 90250, 90250, 90250, 90250, 90250, 90375, 90375, 90500, 90500, 90500, 90500, 90500, 90500, 90500, 90625, 90625, 90625, 90750, 90750, 90750, 90750, 90875, 90875, 91000, 91000, 91000, 91125, 91250, 91250, 91250, 91250, 91250, 91250, 91375, 91375, 91375, 91375, 91500, 91500, 91500, 91625, 91625, 91625, 91625, 91750, 91875, 91875, 91875, 91875, 92000, 92000, 92000, 92000, 92000, 92000, 92000, 92125, 92125, 92125, 92125, 92250, 92250, 92375, 92375, 92500, 92500, 92500, 92500, 92500, 92500, 92625, 92625, 92625, 92625, 92750, 92750, 92750, 92875, 93000, 93000, 93000, 93000, 93000, 93000, 93125, 93125, 93250, 93250, 93375, 93500, 93500, 93500, 93500, 93500, 93500, 93500, 93500, 93625, 93750, 93750, 93750, 93875, 94000, 94000, 94000, 94000, 94000, 94000, 94000, 94125, 94250, 94250, 94250, 94250, 94250, 94250, 94375, 94500, 94500, 94500, 94500, 94500, 94500, 94500, 94625, 94625, 94625, 94750, 94750, 94750, 94875, 94875, 95000, 95000, 95000, 95000, 95125, 95125, 95250, 95250, 95250, 95250, 95250, 95250, 95375, 95375, 95375, 95375, 95375, 95375, 95375, 95375, 95375, 95500, 95500, 95625, 95625, 95625, 95625, 95625, 95625, 95750, 95750, 95750, 95875, 95875, 95875, 95875, 95875, 95875, 95875, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96125, 96125, 96125, 96250, 96250, 96375, 96375, 96500, 96500, 96500, 96500, 96500, 96500, 96625, 96625, 96625, 96750, 96750, 96750, 96875, 97000, 97000, 97000, 97000, 97000, 97000, 97125, 97250, 97250, 97250, 97500, 97500, 97500, 97500, 97500, 97500, 97500, 97500, 97750, 97750, 97750, 97875, 98000, 98000, 98000, 98000, 98000, 98000, 98000, 98000, 98250, 98250, 98250, 98250, 98250, 98250, 98375, 98500, 98500, 98500, 98500, 98500, 98500, 98500, 98500, 98625, 98625, 98750, 98750, 98750, 98750, 98750, 98875, 99000, 99000, 99250, 99250, 99250, 99250, 99250, 99375, 99375, 99375, 99375, 99500, 99625, 99625, 99625, 99625, 99625, 99875, 99875, 99875, 99875, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100125, 100125, 100125, 100250, 100375, 100375, 100500, 100500, 100500, 100500, 100500, 100500, 100625, 100625, 100625, 100750, 100750, 100750, 100875, 101000, 101000, 101000, 101000, 101000, 101000, 101125, 101250, 101250, 101250, 101500, 101500, 101500, 101500, 101500, 101500, 101500, 101500, 101750, 101750, 101750, 101875, 102000, 102000, 102000, 102000, 102000, 102000, 102000, 102000, 102250, 102250, 102250, 102250, 102250, 102250, 102500, 102500, 102500, 102500, 102500, 102500, 102500, 102500, 102500, 102625, 102625, 102750, 102750, 102750, 102750, 102875, 103000, 103000, 103000, 103000, 103000, 103000, 103250, 103250, 103250, 103250, 103250, 103375, 103375, 103375, 103375, 103375, 103375, 103375, 103500, 103625, 103625, 103625, 103625, 103625, 103750, 103875, 103875, 103875, 103875, 103875, 104000, 104000, 104000, 104000, 104250, 104250, 104500, 104500, 104750, 104750, 104750, 104750, 105000, 105000, 105000, 105000, 105250, 105250, 105500, 105500, 105750, 105750, 106000, 106000, 106000, 106000, 106250, 106250, 106500, 106500, 106750, 106750, 106750, 106750, 107000, 107000, 107000, 107000, 107250, 107250, 107500, 107500, 107750, 107750, 108000, 108000, 108000, 108000, 108250, 108250, 108500, 108500, 108750, 108750, 108750, 108750, 109000, 109000, 109000, 109000, 109250, 109250, 109500, 109500, 109750, 109750, 110000, 110000, 110000, 110000, 110250, 110250, 110500, 110500, 110750, 110750, 110750, 110750, 111000, 111000, 111000, 111000, 111125, 111125, 111250, 111250, 111375, 111375, 111500, 111500, 111500, 111500, 111625, 111625, 111750, 111750, 111750, 111750, 111875, 111875, 112000, 112000, 112000, 112000, 112000, 112000, 112125, 112125, 112250, 112250, 112250, 112500, 112500, 112500, 112500, 112500, 112500, 112750, 112750, 112750, 112875, 113000, 113000, 113000, 113000, 113000, 113000, 113125, 113125, 113250, 113250, 113250, 113250, 113250, 113500, 113500, 113500, 113500, 113500, 113500, 113750, 113750, 113750, 113875, 114000, 114000, 114000, 114000, 114000, 114000, 114250, 114250, 114250, 114250, 114250, 114500, 114500, 114500, 114500, 114500, 114500, 115000, 115000, 115000, 115000, 115000, 115000, 115250, 115250, 115250, 115250, 115250, 115500, 115500, 115500, 115500, 115500, 115500, 116000, 116000, 116000, 116000, 116000, 116000, 116125, 116125, 116250, 116250, 116250, 116500, 116500, 116500, 116500, 116500, 116500, 116750, 116750, 116750, 116875, 117000, 117000, 117000, 117000, 117000, 117000, 117125, 117125, 117250, 117250, 117250, 117250, 117250, 117500, 117500, 117500, 117500, 117500, 117500, 117750, 117750, 117750, 117875, 118000, 118000, 118000, 118000, 118000, 118000, 118750, 118750, 119000, 119000, 120000, 120000, 120000, 120000, 120000, 120000, 120125, 120125, 120250, 120250, 120250, 120500, 120500, 120500, 120500, 120500, 120500, 120750, 120750, 120750, 120875, 121000, 121000, 121000, 121000, 121000, 121000, 121125, 121125, 121250, 121250, 121250, 121250, 121250, 121500, 121500, 121500, 121500, 121500, 121500, 121750, 121750, 121750, 121875, 122000, 122000, 122000, 122000, 122000, 122000, 122250, 122250, 122250, 122250, 122250, 122500, 122500, 122500, 122500, 122500, 122500, 123000, 123000, 123000, 123000, 123000, 123000, 123250, 123250, 123250, 123250, 123250, 123500, 123500, 123500, 123500, 123500, 123500, 124000, 124000, 124000, 124000, 124000, 124000, 124125, 124125, 124250, 124250, 124250, 124500, 124500, 124500, 124500, 124500, 124500, 124750, 124750, 124750, 124875, 125000, 125000, 125000, 125000, 125000, 125000, 125125, 125125, 125250, 125250, 125250, 125250, 125250, 125500, 125500, 125500, 125500, 125500, 125500, 125750, 125750, 125750, 125875, 126000, 126000, 126000, 126000, 126000
notes: .word 44, 44, 87, 90, 44, 47, 24, 35, 44, 44, 87, 90, 39, 44, 39, 39, 42, 24, 35, 44, 43, 86, 89, 44, 44, 44, 47, 24, 35, 44, 86, 89, 44, 39, 44, 24, 24, 35, 44, 44, 85, 88, 44, 47, 24, 35, 44, 44, 85, 88, 39, 44, 39, 39, 42, 24, 35, 44, 39, 83, 87, 44, 24, 35, 61, 61, 61, 61, 39, 35, 43, 61, 37, 38, 35, 36, 34, 32, 21, 35, 54, 55, 82, 32, 75, 80, 82, 35, 43, 54, 61, 82, 32, 82, 27, 75, 80, 21, 35, 54, 82, 27, 27, 82, 30, 43, 54, 61, 82, 31, 82, 32, 75, 80, 21, 35, 54, 82, 32, 82, 35, 43, 54, 61, 82, 32, 75, 80, 82, 27, 21, 35, 54, 82, 82, 43, 54, 61, 82, 82, 21, 35, 54, 82, 32, 75, 80, 82, 35, 43, 54, 61, 82, 32, 82, 27, 75, 80, 21, 35, 54, 82, 27, 27, 82, 30, 43, 54, 61, 82, 27, 82, 32, 73, 78, 21, 35, 54, 82, 32, 82, 35, 43, 54, 61, 82, 32, 75, 80, 82, 35, 21, 35, 54, 82, 82, 43, 54, 61, 82, 82, 32, 21, 35, 54, 82, 32, 75, 80, 82, 35, 43, 54, 61, 82, 32, 82, 27, 75, 80, 21, 35, 54, 82, 27, 27, 82, 30, 43, 54, 61, 82, 31, 82, 32, 75, 80, 21, 35, 54, 82, 32, 82, 35, 43, 54, 61, 82, 32, 75, 80, 82, 27, 21, 35, 54, 82, 82, 43, 54, 61, 82, 82, 21, 35, 54, 82, 32, 75, 80, 82, 35, 43, 54, 61, 82, 32, 82, 27, 75, 80, 21, 35, 54, 82, 27, 27, 82, 30, 43, 54, 61, 82, 27, 82, 49, 50, 21, 35, 54, 82, 48, 46, 47, 82, 44, 45, 42, 43, 43, 54, 61, 82, 40, 41, 39, 35, 82, 37, 43, 35, 21, 41, 43, 54, 62, 64, 41, 62, 64, 35, 41, 62, 64, 41, 62, 64, 43, 54, 61, 66, 32, 21, 35, 54, 82, 32, 75, 82, 35, 71, 43, 54, 61, 82, 32, 75, 82, 27, 71, 21, 35, 54, 82, 27, 27, 82, 30, 43, 54, 61, 82, 31, 82, 32, 68, 21, 35, 54, 82, 32, 68, 82, 35, 71, 43, 54, 61, 82, 32, 68, 82, 27, 71, 21, 35, 54, 82, 82, 43, 54, 61, 82, 82, 21, 35, 54, 82, 32, 75, 82, 35, 71, 43, 54, 61, 82, 32, 75, 82, 27, 78, 21, 35, 54, 82, 27, 27, 82, 30, 77, 77, 43, 54, 61, 82, 27, 73, 82, 32, 58, 21, 35, 54, 82, 32, 82, 35, 43, 54, 61, 82, 32, 82, 35, 21, 35, 54, 82, 82, 43, 54, 61, 82, 82, 32, 21, 35, 54, 82, 32, 75, 82, 75, 35, 71, 43, 54, 61, 82, 32, 75, 82, 27, 71, 21, 35, 54, 82, 27, 27, 82, 30, 43, 54, 61, 82, 31, 82, 32, 68, 21, 35, 54, 82, 32, 68, 82, 35, 71, 43, 54, 61, 82, 32, 68, 82, 27, 63, 21, 35, 54, 82, 35, 82, 43, 54, 61, 82, 82, 21, 35, 54, 82, 32, 75, 82, 35, 71, 43, 54, 61, 82, 32, 75, 82, 27, 78, 21, 35, 54, 82, 27, 27, 82, 30, 77, 43, 54, 61, 82, 27, 73, 82, 32, 75, 29, 35, 54, 82, 32, 35, 82, 35, 43, 54, 61, 82, 32, 29, 35, 82, 35, 43, 54, 61, 82, 43, 61, 29, 35, 82, 43, 61, 82, 32, 44, 56, 68, 35, 54, 82, 80, 68, 82, 68, 80, 24, 35, 54, 82, 68, 68, 82, 80, 68, 54, 82, 80, 68, 82, 68, 80, 24, 35, 54, 82, 68, 68, 82, 80, 35, 47, 54, 68, 54, 82, 80, 68, 82, 68, 80, 24, 35, 54, 82, 68, 68, 82, 80, 68, 54, 82, 80, 68, 82, 68, 80, 24, 35, 54, 82, 68, 68, 82, 80, 37, 49, 53, 68, 24, 54, 82, 80, 68, 82, 68, 80, 24, 35, 54, 82, 68, 68, 82, 80, 68, 24, 54, 82, 80, 68, 82, 68, 80, 24, 35, 54, 82, 68, 68, 82, 80, 38, 50, 52, 68, 24, 54, 82, 80, 68, 24, 82, 68, 80, 24, 54, 82, 68, 68, 24, 82, 80, 61, 68, 54, 61, 82, 80, 61, 68, 61, 82, 68, 61, 80, 43, 45, 54, 61, 66, 82, 32, 24, 35, 54, 82, 32, 92, 95, 82, 35, 92, 43, 54, 61, 82, 32, 87, 24, 82, 32, 92, 96, 24, 35, 54, 82, 82, 92, 43, 54, 61, 82, 87, 82, 32, 92, 97, 24, 35, 54, 82, 32, 92, 82, 35, 87, 43, 54, 61, 82, 32, 92, 96, 24, 35, 82, 32, 24, 35, 54, 82, 32, 24, 35, 54, 82, 32, 92, 95, 82, 35, 92, 43, 54, 61, 82, 32, 87, 24, 82, 32, 92, 96, 24, 35, 54, 82, 82, 92, 43, 54, 61, 82, 87, 82, 32, 92, 97, 24, 35, 54, 82, 32, 92, 82, 35, 87, 43, 54, 61, 82, 32, 92, 96, 24, 35, 82, 32, 24, 35, 54, 82, 32, 24, 35, 54, 82, 32, 92, 95, 82, 35, 92, 43, 54, 61, 82, 32, 87, 24, 35, 82, 32, 92, 96, 24, 35, 54, 82, 82, 92, 43, 54, 61, 82, 87, 82, 32, 92, 97, 24, 35, 54, 82, 32, 92, 82, 35, 87, 43, 54, 61, 82, 32, 92, 96, 24, 35, 82, 32, 24, 35, 54, 82, 32, 24, 35, 54, 82, 32, 92, 95, 82, 35, 92, 43, 54, 61, 82, 32, 87, 24, 35, 82, 32, 92, 96, 24, 35, 54, 82, 82, 92, 43, 54, 61, 82, 87, 82, 32, 92, 97, 24, 35, 54, 82, 32, 92, 82, 35, 87, 43, 54, 61, 82, 32, 92, 96, 24, 35, 82, 32, 24, 35, 54, 82, 24, 35, 54, 82, 75, 80, 82, 43, 54, 61, 82, 82, 75, 80, 24, 35, 54, 82, 82, 43, 54, 61, 82, 82, 75, 80, 24, 35, 54, 82, 82, 43, 54, 61, 82, 75, 80, 24, 35, 54, 82, 24, 73, 78, 43, 61, 61, 24, 35, 54, 82, 75, 80, 82, 43, 54, 61, 82, 82, 75, 80, 24, 35, 54, 82, 82, 43, 54, 61, 82, 82, 75, 80, 24, 35, 54, 82, 82, 43, 54, 61, 82, 43, 61, 75, 80, 24, 43, 61, 43, 54, 61, 82, 47, 61, 61, 45, 39, 73, 78, 24, 45, 37, 38, 24, 43, 35, 36, 24, 34, 43, 32, 24, 35, 54, 82, 32, 32, 75, 80, 82, 32, 43, 54, 61, 82, 35, 82, 32, 75, 80, 24, 35, 54, 82, 32, 82, 32, 43, 54, 61, 82, 27, 82, 32, 75, 80, 24, 35, 54, 82, 32, 32, 82, 32, 43, 54, 61, 82, 35, 75, 80, 82, 32, 24, 35, 54, 82, 33, 82, 32, 73, 78, 43, 54, 61, 82, 33, 82, 32, 24, 35, 54, 82, 32, 32, 75, 80, 82, 32, 43, 54, 61, 82, 35, 82, 32, 75, 80, 24, 35, 54, 82, 32, 82, 32, 43, 54, 61, 82, 27, 80, 82, 32, 75, 80, 24, 35, 54, 82, 32, 82, 32, 43, 61, 82, 32, 75, 80, 24, 35, 54, 82, 37, 37, 83, 24, 51, 54, 57, 82, 37, 37, 80, 24, 83, 51, 82, 80, 51, 83, 40, 51, 54, 61, 82, 29, 29, 80, 24, 83, 51, 82, 80, 51, 30, 30, 83, 24, 54, 82, 80, 51, 83, 51, 82, 80, 32, 32, 83, 40, 51, 54, 61, 82, 80, 83, 51, 82, 80, 51, 34, 34, 85, 24, 51, 54, 55, 82, 77, 34, 34, 78, 24, 51, 82, 79, 51, 32, 32, 80, 40, 51, 54, 61, 82, 34, 34, 82, 83, 24, 51, 55, 82, 82, 24, 54, 82, 87, 40, 40, 85, 40, 61, 82, 41, 41, 83, 40, 61, 82, 54, 82, 37, 37, 80, 40, 61, 78, 82, 32, 32, 77, 40, 61, 37, 37, 78, 24, 51, 54, 57, 82, 37, 37, 24, 77, 51, 82, 75, 51, 66, 73, 40, 51, 54, 61, 82, 29, 29, 24, 51, 82, 51, 30, 30, 24, 54, 82, 71, 51, 63, 51, 82, 65, 32, 32, 66, 40, 51, 54, 61, 82, 68, 70, 51, 82, 68, 51, 34, 34, 75, 24, 51, 54, 82, 70, 34, 34, 71, 24, 51, 82, 73, 32, 32, 75, 40, 51, 54, 61, 82, 34, 34, 77, 78, 24, 51, 82, 77, 24, 51, 55, 54, 82, 80, 40, 40, 71, 40, 61, 82, 41, 41, 73, 40, 61, 75, 54, 82, 37, 37, 77, 40, 61, 78, 82, 32, 32, 77, 40, 61, 37, 37, 80, 24, 51, 54, 57, 82, 37, 37, 80, 24, 51, 82, 70, 51, 40, 51, 54, 61, 82, 29, 29, 71, 24, 51, 82, 73, 51, 30, 30, 75, 24, 54, 82, 73, 51, 75, 51, 82, 32, 32, 77, 40, 51, 54, 61, 82, 51, 82, 51, 82, 34, 34, 80, 24, 51, 54, 55, 82, 80, 34, 34, 24, 51, 82, 70, 51, 32, 32, 40, 51, 54, 61, 82, 34, 34, 71, 24, 51, 55, 82, 73, 24, 75, 54, 82, 73, 40, 40, 75, 40, 61, 82, 41, 41, 40, 61, 77, 54, 82, 37, 37, 40, 61, 82, 32, 32, 40, 61, 37, 37, 77, 24, 54, 57, 82, 37, 37, 83, 24, 51, 82, 85, 51, 84, 40, 51, 54, 61, 82, 29, 29, 83, 24, 82, 51, 82, 51, 30, 30, 81, 24, 54, 82, 80, 51, 51, 82, 79, 32, 32, 78, 40, 51, 54, 61, 82, 77, 76, 51, 82, 51, 34, 34, 75, 24, 51, 54, 82, 74, 34, 34, 73, 24, 51, 82, 54, 32, 32, 72, 40, 51, 61, 82, 34, 34, 71, 24, 51, 54, 70, 24, 69, 51, 55, 82, 68, 54, 40, 40, 66, 67, 40, 61, 41, 41, 65, 40, 51, 54, 55, 57, 61, 64, 82, 37, 37, 63, 40, 54, 61, 61, 62, 51, 32, 32, 59, 60, 40, 54, 61, 37, 37, 80, 24, 51, 57, 82, 37, 37, 24, 51, 54, 85, 51, 84, 40, 51, 54, 61, 82, 29, 29, 24, 82, 51, 54, 51, 30, 30, 80, 24, 54, 82, 51, 82, 51, 54, 32, 32, 77, 40, 51, 54, 61, 82, 78, 51, 54, 51, 34, 34, 80, 24, 51, 54, 55, 82, 34, 34, 85, 24, 51, 54, 51, 32, 32, 84, 40, 51, 54, 61, 82, 34, 34, 85, 24, 51, 54, 55, 24, 54, 82, 40, 40, 40, 54, 61, 41, 41, 40, 61, 82, 37, 37, 40, 54, 61, 32, 32, 40, 61, 37, 37, 82, 24, 54, 57, 82, 37, 37, 24, 51, 89, 51, 87, 40, 51, 54, 61, 82, 29, 29, 24, 86, 51, 54, 51, 30, 30, 84, 24, 54, 82, 51, 86, 51, 54, 32, 32, 80, 40, 51, 54, 61, 82, 51, 54, 71, 51, 34, 34, 82, 24, 51, 54, 82, 21, 34, 34, 24, 51, 54, 77, 32, 32, 88, 40, 51, 54, 61, 82, 21, 34, 34, 24, 51, 54, 82, 24, 93, 51, 54, 55, 82, 21, 40, 40, 40, 54, 61, 41, 41, 40, 51, 55, 57, 61, 82, 37, 37, 40, 54, 61, 51, 32, 32, 40, 54, 61, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 24, 35, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 24, 35, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 24, 35, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 31, 43, 24, 35, 32, 44, 32, 44, 32, 44, 24, 35, 31, 43, 43, 61, 43, 61, 32, 44, 24, 35, 32, 44, 24, 35, 43, 61, 32, 44, 43, 61, 43, 61, 32, 44, 24, 35, 54, 82, 32, 44, 32, 44, 82, 35, 47, 43, 54, 61, 82, 37, 49, 82, 82, 38, 50, 24, 35, 54, 82, 38, 50, 38, 50, 24, 35, 82, 37, 49, 43, 54, 61, 82, 35, 47, 82, 82, 32, 44, 24, 35, 54, 82, 32, 44, 24, 35, 82, 35, 47, 43, 54, 61, 82, 32, 44, 24, 35, 54, 82, 32, 44, 24, 35, 82, 35, 47, 43, 54, 61, 82, 32, 44, 24, 35, 54, 82, 32, 44, 32, 44, 82, 35, 47, 43, 54, 61, 82, 37, 49, 82, 82, 38, 50, 24, 35, 54, 82, 38, 50, 38, 50, 24, 35, 82, 37, 49, 43, 54, 61, 82, 35, 47, 82, 82, 32, 44, 24, 35, 54, 82, 24, 35, 24, 35, 32, 44, 24, 35, 54, 82, 32, 44, 32, 44, 82, 35, 47, 43, 54, 61, 82, 37, 49, 82, 82, 38, 50, 24, 35, 54, 82, 38, 50, 38, 50, 24, 35, 82, 37, 49, 43, 54, 61, 82, 35, 47, 82, 82, 32, 44, 24, 35, 54, 82, 32, 44, 24, 35, 82, 35, 47, 43, 54, 61, 82, 32, 44, 24, 35, 54, 82, 32, 44, 24, 35, 82, 35, 47, 43, 54, 61, 82, 32, 44, 24, 35, 54, 82, 32, 44, 32, 44, 82, 35, 47, 43, 54, 61, 82, 37, 49, 82, 82, 38, 50, 24, 35, 54, 82, 38, 50, 38, 50, 24, 35, 82, 37, 49, 43, 54, 61, 82, 35, 47, 82, 82, 32, 44, 21, 35, 54
velocity: .word 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50
duration: .word 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240

##############################################################################
# Mutable Data
##############################################################################
game_array:             .word 0:128         # array containing the game
capsuleID_array:        .word 0:128         # array containing the capsuleIDs

curr_x1:                .word 0             # current x of half 1
curr_y1:                .word 0             # current y of half 1
curr_x2:                .word 0             # current x of half 2
curr_y2:                .word 0             # current y of half 2

new_x1:                 .word 0             # current x of half 1
new_y1:                 .word 0             # current y of half 1
new_x2:                 .word 0             # current x of half 2
new_y2:                 .word 0             # current y of half 2

colour_1:               .word 0             # current colour of half 1
colour_2:               .word 0             # current colour of half 2

next_pill_colour1:      .word 0xffffff             # next colour of half 1
next_pill_colour2:      .word 0xffffff             # next colour of half 2

capsuleID_count:        .word 0             # increases each time a capsule is added to the board
capsuleID_max:          .word 0             # only used in drop to save the current capsuleID_count

current_mode:           .word 0             # used to set the mode to easy, medium, or hard
current_screen:         .word 0             # 0 = mode_screen, 1 = game_screen, 2 = game_over_screen, 3 = paused_state

virus_number:           .word 0             # used to set the number of viruses (per the game mode)
game_speed:             .word 0             # used to set the game speed (per the game mode) 

sleep_count:            .word 0             # counts the number of sleep cycles (0.25 sec)

music_sleep_count:      .word 0             # counts the number of sleep cycles to sync backgroung music 
music_array_offset:     .word 0             # counts the current offset for all the music-related arrays
##############################################################################
# Code
##############################################################################
.macro store_registers() 
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t9, 0($sp)              # Store the value of $t9 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t8, 0($sp)              # Store the value of $t8 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t7, 0($sp)              # Store the value of $t7 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t6, 0($sp)              # Store the value of $t6 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t5, 0($sp)              # Store the value of $t5 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t4, 0($sp)              # Store the value of $t4 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t3, 0($sp)              # Store the value of $t3 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t2, 0($sp)              # Store the value of $t2 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t1, 0($sp)              # Store the value of $t1 at the top of the stack
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $t0, 0($sp)              # Store the value of $t0 at the top of the stack
.end_macro

.macro load_registers() 
    lw $t0, 0($sp)           # Load the saved value of $t0 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t1, 0($sp)           # Load the saved value of $t1 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t2, 0($sp)           # Load the saved value of $t2 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t3, 0($sp)           # Load the saved value of $t3 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t4, 0($sp)           # Load the saved value of $t4 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t5, 0($sp)           # Load the saved value of $t5 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t6, 0($sp)           # Load the saved value of $t6 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t7, 0($sp)           # Load the saved value of $t7 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t8, 0($sp)           # Load the saved value of $t8 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    lw $t9, 0($sp)           # Load the saved value of $t9 from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
.end_macro	
	
	.text
	.globl main

    # Run the game.
main:
    # Start with the mode_screen to choose a level (easy, med, hard)
    jal mode_screen
    jal clear_screen
    
    # set current screen = 1 (game screen)
    la $t0, current_screen
    addi $t1, $zero, 1
    sw $t1, 0($t0)

    # Initialize the game
    jal draw_bottle                 # draw the bottle
    
    lw $a0, virus_number              # number of viruses 
    jal generate_virus              # add viruses to game_array
    
    jal update_display
    jal generate_pill               # initialise pill in data (curr_x, curr_y, new_x, new_y)
    jal generate_pill               # initialise pill in data (curr_x, curr_y, new_x, new_y)
    jal update_capsule_location     # initialise location of pill
    jal update_display              # draw the display

game_loop:
     # 4. Sleep
	li $v0, 32
	li $a0, 25
	syscall
	
	# play music notes
	jal play_music_note
	
	# increment music_sleep_count
	la $t0, music_sleep_count        # address of sleep_count
	lw $t1, music_sleep_count        # value of music_sleep_count
	addi $t1, $t1, 25                # increment music_sleep_count by 25 (ms)
	sw $t1, 0($t0)
	
	# gravity 
	la $t0, sleep_count        # address of sleep_count
	lw $t1, sleep_count        # value of sleep_count
	
	lw $t3, game_speed
	bge $t1, $t3, trigger_gravity
	j skip_trigger_gravity             # otherwise, we don't need to trigger gravity
	
	trigger_gravity:
	add $t1, $zero, $zero
	sw $t1, 0($t0)
	
	lw $t2, s
	add $s0, $t2, $zero             # s0 = keypress (constant for the loop)
	add $a0, $t2, $zero             # set a0 arg to be ascii of S
	j simulate_gravity
	
	skip_trigger_gravity:
	addi $t1, $t1, 1                   # increment sleep count by 1
	sw $t1, 0($t0)                     # store sleep_count value 

    # 1A. CHECK IF KEY HAS BEEN PRESSED & 1B. CHECK WHICH KEY HAS BEEN PRESSED
    jal check_key_press
    
    add $s0, $v0, $zero             # s0 = keypress (constant for the loop)
    add $a0, $s0, $zero             # output key from check_key_press is the input to calculate_next_xy
    
    simulate_gravity:
    jal calculate_new_xy            # after this call, new_x and new_y will contain new positions
    
    # 2A. CHECK FOR COLLISIONS
    # remove the current values from the game_array
    la $t5, game_array          # load the address of the game_array
    la $t4, capsuleID_array     # load the address of the capsuleID_array
    
    # remove value of game_array[curr_x1, curr_y1] 
    lw $t7, curr_x1              # t1 = curr_x1
    lw $t8, curr_y1              # t2 = curr_y1
    add $a0, $t7, $zero          # arg x for xy_to_array
    add $a1, $t8, $zero          # arg y for xy_to_array
    jal xy_to_array
    
    add $t0, $t5, $v0           # points to game_array[curr_x1, curr_y1]
    lw $t9, black               # load the colour black
    sw $t9, 0($t0)              # put the colour black into game_array[curr_x1, curr_y1]
    
    add $t1, $t4, $v0           # points to capsuleID_array[curr_x1, curr_y1]
    sw $zero, 0($t1)            # put zero into the capsuleID_array[curr_x1, curr_y1]
    
    # remove value of game_array[curr_x2, curr_y2]
    lw $t7, curr_x2              # t1 = curr_x2
    lw $t8, curr_y2              # t2 = curr_y2
    add $a0, $t7, $zero          # arg x for xy_to_array
    add $a1, $t8, $zero          # arg y for xy_to_array
    jal xy_to_array
    add $t0, $t5, $v0           # points to game_array[curr_x2, curr_y2]
    lw $t9, black               # load the colour black
    sw $t9, 0($t0)              # put the colour black into game_array[curr_x2, curr_y2]
    add $t1, $t4, $v0           # points to capsuleID_array[curr_x1, curr_y1]
    sw $zero, 0($t1)            # put zero into the capsuleID_array[curr_x1, curr_y1]
    
    beq $s0, 0x61, check_side_collision                         # the given key is a
    beq $s0, 0x64, check_side_collision                         # the given key is d
    beq $s0, 0x77, check_side_collision                         # the given key is w
    beq $s0, 0x73, check_down_collision                         # the given key is s
    j location
    
    check_side_collision:
    jal check_wall_collision            # checks if the pill hit the side or top walls
    beq $v0, 1, location                # returns 1 if collision
    
    # otherwise, the pill did not hit a wall
    jal check_object_collision          # checks if the pill hit an object
    beq $v0, 1, location                # returns 1 if collision
    
    # otherwise, we can move the pill to the new position
    # update curr_x, curr_y = new_x, new_y
    beq $s0, 0x77, play_rotate_sound                         # the given key is w
    
    # otherwise, we know either a or d was pressed
    play_shift_sound:
    jal shift_sound
    j shift_capsule
    
    play_rotate_sound:
    jal rotate_sound
    j shift_capsule
    
    shift_capsule:
    la $t1, curr_x1         # t1 = curr_x1 address
    lw $t2, new_x1          # t2 = new_x1
    sw $t2, 0($t1)          # store new_x1 at curr_x1 address
    
    la $t1, curr_y1         # t1 = curr_y1 address
    lw $t2, new_y1          # t2 = new_y1
    sw $t2, 0($t1)          # store new_y1 at curr_y1 address
    
    la $t1, curr_x2         # t1 = curr_x2 address
    lw $t2, new_x2          # t2 = new_x2
    sw $t2, 0($t1)          # store new_x2 at curr_x2 address
    
    la $t1, curr_y2         # t1 = curr_y2 address
    lw $t2, new_y2          # t2 = new_y2
    sw $t2, 0($t1)          # store new_y2 at curr_y2 address
    
    j location
    
    check_down_collision:
    jal check_bottom_collision          # checks if the pill hit the bottom of the walls
    beq $v0, 1, down_collision_true                # returns 1 if collision
    
    # otherwise, the pill did not hit a wall
    jal check_object_collision          # checks if the pill hit an object
    beq $v0, 1, down_collision_true                # returns 1 if collision
    
    # otherwise, we can move the pill to the new position
    # update curr_x, curr_y = new_x, new_y
    
    la $t1, curr_x1         # t1 = curr_x1 address
    lw $t2, new_x1          # t2 = new_x1
    sw $t2, 0($t1)          # store new_x1 at curr_x1 address
    
    la $t1, curr_y1         # t1 = curr_y1 address
    lw $t2, new_y1          # t2 = new_y1
    sw $t2, 0($t1)          # store new_y1 at curr_y1 address
    
    la $t1, curr_x2         # t1 = curr_x2 address
    lw $t2, new_x2          # t2 = new_x2
    sw $t2, 0($t1)          # store new_x2 at curr_x2 address
    
    la $t1, curr_y2         # t1 = curr_y2 address
    lw $t2, new_y2          # t2 = new_y2
    sw $t2, 0($t1)          # store new_y2 at curr_y2 address

    j location
    
    down_collision_true:
    jal collide_sound
    jal update_capsule_location
    jal merge_row
    jal merge_column
    jal generate_pill
    j location 
        
	# 2B. UPDATE LOCATION (CAPSULES)
	location:
	jal update_capsule_location             # after this call, the game_array locations should be updated
	jal check_win
	addi $a0, $zero, 1
	beq $v0, 1, game_over_screen
	
	# 3. Draw the screen
	jal update_display

    # 5. Go back to Step 1
    j game_loop
    
   

##############################################################################
# FUNCTIONS
##############################################################################

# FUNCTION THAT DRAWS THE BOTTLE
# registers used: t0 (bitmap pointer), t1 (counter for x/y), t9 (the colour white)
draw_bottle:
    lw $t0, ADDR_DSPL                # load displayAddress into $t0 (= bitmap pointer)
    addi $t0, $t0, 1460              # shift the bitmap pointer ($t0) to the start of the bottle (top left unit) 
    
    lw $t9, white               # $t9 = the colour white
    
    # START OF BOTTLE TOP AND NECK
    sw $t9, 0($t0)              # row 1
    addi $t0, $t0, 20
    sw $t9, 0($t0) 
    
    addi $t0, $t0, 108          # shift to row 2
    
    sw $t9, 0($t0)              # row 2
    addi $t0, $t0, 4
    sw $t9, 0($t0) 
    addi $t0, $t0, 12
    sw $t9, 0($t0)
    addi $t0, $t0, 4
    sw $t9, 0($t0)
    
    addi $t0, $t0, 112          # shift to row 3 (bottleneck)
    
    sw$t9, 0($t0)               # row 3
    addi $t0, $t0, 12
    sw $t9, 0($t0)
    # END OF BOTTLE TOP AND NECK
    
    addi $t0, $t0, 104          # shift to row 4 (top of bottle body)
    
    # TOP OF BOTTLE BODY #
    sw $t9, 0($t0)      
    addi $t0, $t0, 4
    sw $t9, 0($t0)      
    addi $t0, $t0, 4
    sw $t9, 0($t0)      
    addi $t0, $t0, 4
    sw $t9, 0($t0)      
    
    addi $t0, $t0, 12
    
    sw $t9, 0($t0)      
    addi $t0, $t0, 4
    sw $t9, 0($t0)      
    addi $t0, $t0, 4
    sw $t9, 0($t0)      
    addi $t0, $t0, 4
    sw $t9, 0($t0) 
    # END OF BOTTLE BODY #
    
    add $t1, $zero, $zero       # initialize $t1 = counter for y
    
    # START OF BOTTLE SIDES #
    bottle_body_side:
    addi $t0, $t0, 92               # shift to next row of the bottle body
    sw $t9, 0($t0)                  # left side
    addi $t0, $t0, 36
    sw $t9, 0($t0)                  # right side
    addi, $t1, $t1, 1
    bne $t1, 16, bottle_body_side  # loop 16 times
    # END OF BOTTLE SIDES #
    
    add $t1, $zero, $zero       # reassign $t1 = counter for x
    addi $t0, $t0, 92           # shift to last row
    
    # START OF BOTTOM OF BOTTLE # 
    bottle_bottom:
    sw $t9, 0($t0)                  
    addi, $t0, $t0, 4
    addi, $t1, $t1, 1
    bne $t1, 10, bottle_bottom
    # END OF BOTTOM OF BOTTLE # 
    jr $ra 
# END DRAW_BOTTLE

# START GENERATE_VIRUS
# function that generates a random coloured virus at a random location in the bottom half of the bottle and stores the virus in the game_array
# inputs: a0 (number of viruses to generate)
# registers: t0 (game_array pointer), t1 (generated x value), t2 (generated y value), t3 (generated colour), t4 (capsuleID_array), t5 (game_array pointer)
#            t6 (value at game_array pointer), t7 (loop bound), t8 (virus counter)
generate_virus: 
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    add $t7, $a0, $zero         # init loop bound to a0
    add $t8, $zero, $zero       # init loop counter to 0
    
    generate_virus_loop:
        la $t5, game_array          # load the base address of the game_array
        la $t4, capsuleID_array     # load the base address of the capsuleID_array
        
        jal generate_colour         # generate the colour of the virus
        add $t3, $v0, $zero         # store generated colour in t3
        
        # Generate x value (random number between 0 and 8 (exc.)) 
        li $v0, 42                  # Syscall for random number (min = a0, max = a1)
        li $a0, 0
        li $a1, 8
        syscall
        add $t1, $a0, $zero         # t1 = generated x value
        
        # Generate y value (random number between 8 and 16 (exc.))
        li $v0, 42             # Syscall for random number (min = a0, max = a1)
        li $a0, 0
        li $a1, 8
        syscall
        addi $t2, $a0, 8        # t2 = generated y value (+8 because the value generated is from 0-7, not 8-15)
        
        # Get array offset
        add $a0, $t1, $zero         # a0 = x arg for xy_to_array
        add $a1, $t2, $zero         # a1 = y arg for xy_to_array
        jal xy_to_array
        
        # If the given address is empty, set the virus
        # If the given address already contains a virus, loop again without setting.
        add $t5, $t5, $v0                   # add offset to base game_array address
        add $t4, $t4, $v0                   # add offset to base address of the capsuleID_array
        lw $t6, 0($t5)                      # load the value at the offset game_array address at t6
        beq $t6, $zero, set_virus           # if the value is equal to 0 (is empty), set the virus
        j next_generate_virus_loop          # otherwise, start the loop again
        
        set_virus:
            sw $t3, 0($t5)              # store the colour of the virus at this offset
            add $t9, $zero, -1          # t9 = -1
            sw $t9, 0($t4)              # store -1 (virus id) at this offset
            addi $t8, $t8, 1            # increase the virus counter by 1
            j next_generate_virus_loop
        
        next_generate_virus_loop:
        blt $t8, $t7, generate_virus_loop       # exit when t8 (virus counter) = t7 = a0 = loop bound       
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)

    jr $ra
# END GENERATE_VIRUS

# FUNCTION THAT GENERATES A RANDOM BI-COLOURED PILL AND DRAWS IT AT THE TOP OF THE BOTTLE
# registers: t0 (game_array pointer), t1 (initial position of left half), v0 (return val from generate_colour)
generate_pill: 
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    # checks if there is something blocking the entrance already
    lw $t1, init_x1             # load initial x1 value into t1
    lw $t2, init_y1             # load initial y1 value into t2    
    la $t9, new_x1              # t9 = address of new_x1
    la $t8, new_y1              # t8 = address of new_y1
    sw $t1, 0($t9)              # store intial x1 value in new_x1
    sw $t2, 0($t8)              # store intial y1 value in new_y1
    
    lw $t1, init_x2             # load initial x2 value into t1
    lw $t2, init_y2             # load initial y2 value into t2
    la $t9, new_x2              # t9 = address of new_x2
    la $t8, new_y2              # t8 = address of new_y2
    sw $t1, 0($t9)              # store intial x2 value in new_x2
    sw $t2, 0($t8)              # store intial y2 value in new_y2
    
    jal check_object_collision
    beq $v0, 0, skip_game_over      # if there is no object at 
    addi $a0, $zero, 0
    j game_over_screen
    
    skip_game_over:
    # set current colours = next pill colours
    la $t7, colour_1
    lw $t8, next_pill_colour1
    sw $t8, 0($t7)                  # store next_pill_colour1 at colour_1
    
    la $t7, colour_2
    lw $t8, next_pill_colour2
    sw $t8, 0($t7)                  # store next_pill_colour2 at colour_2
    
    # generate colours for the next pills
    la $t7, next_pill_colour1            # t7 = address of next_pill_colour1
    jal generate_colour                  # generate the colour of the next pill
    sw $v0, 0($t7)                       # store generated colour in next_pill_colour1
    
    la $t7, next_pill_colour2            # t7 = address of next_pill_colour2
    jal generate_colour                  # generate the colour of the next pill
    sw $v0, 0($t7)                       # store generated colour in next_pill_colour1
    
    # display the next pill on the bitmap
    jal display_next_pill
    
    # reset curr_x, curr_y to initial positions
    la $t9, curr_x1             # t9 = address of x1
    la $t8, curr_y1             # t8 = address of y1
    lw $t1, init_x1             # load initial x1 value into t1
    lw $t2, init_y1             # load initial y1 value into t2
    sw $t1, 0($t9)              # store intial x1 value in curr_x1
    sw $t2, 0($t8)              # store intial y1 value in curr_y1
    
    la $t9, curr_x2             # t9 = address of x2
    la $t8, curr_y2             # t8 = address of y2
    lw $t1, init_x2             # load initial x2 value into t1
    lw $t2, init_y2             # load initial y2 value into t2
    sw $t1, 0($t9)              # store intial x2 value in curr_x2
    sw $t2, 0($t8)              # store intial y2 value in curr_y2
    
    # add one to capsuleID_count
    la $t6, capsuleID_count     # address of capsuleID_count
    lw $t5, capsuleID_count     # value of capsuleID_count
    addi $t5, $t5, 1            # add one to the capsuleID_count
    sw $t5, 0($t6)              # store capsuleID_count + 1 
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    jr $ra
# END GENERATE_PILL

# FUNCTION THAT GENERATES A RANDOM COLOUR (red, yellow, blue)
# registers: v0 (syscall + func return val), a0 (syscall arg + syscall return), a1 (syscall arg), t9 (temp_colour)
generate_colour:
    # Generate random number between 0 and 2 
    li $v0, 42             # Syscall for random number (min = a0, max = a1)
    li $a0, 0
    li $a1, 3
    syscall                
    
    beq $a0, 0, choose_red         # If random number is 0, use red
    beq $a0, 1, choose_yellow      # If random number is 1, use yellow
    beq $a0, 2, choose_blue        # If random number is 2, use blue
    
    choose_red:
    lw $t9, red            # load $t0 = red_address
    j exit_generate_colour
    
    choose_yellow:
    lw $t9, yellow         # load $t0 = yellow_address
    j exit_generate_colour
    
    choose_blue:
    lw $t9, blue           # load $t0 = blue_address
    j exit_generate_colour
    
    exit_generate_colour:
    add $v0, $t9, $zero
    jr $ra
# END GENERATE_COLOUR

# START UPDATE_DISPLAY
# function that updates the display based on the game_array
# registers: t0 (bitmap pointer), t5 (array pointer), t7 (value at game_array[offset/4]), t8 (offset counter), t9 (loop counter)
update_display:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    ############
    store_registers()           # store registers
    
    la $t5, game_array              # load array address into t5
    add $t9, $zero, $zero           # init loop counter = 0
    add $t8, $zero, $zero           # init offset counter = 0
    
    # loops through each address in the array 
    update_display_loop:
        lw $t7, 0($t5)            # load val at game_array[offset/4] into t7 (a colour)
        
        # display_pixel:
        add $a0, $t8, $zero             # array offset arg for array_to_xy
        jal array_to_xy
    
        add $a0, $v0, $zero             # x arg for xy_to_bitmap
        add $a1, $v1, $zero             # y arg for xy_to_bitmap
        jal xy_to_bitmap
        
        lw $t0, ADDR_DSPL               # load the base bitmap address into t0
        add $t0, $t0, $v0
        sw $t7, 0($t0)                  # write value (t7, a colour) to bitmap with offset (v0)
        
        increment_display_loop_vars:
        addi $t9, $t9, 1                        # increase loop counter by 1
        addi $t8, $t8, 4                        # increase offset counter by 4
        addi $t5, $t5, 4                        # increase array pointer by 4
        blt $t9, 128, update_display_loop       # loop 128 times
    
    load_registers()
    ###############
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF UPDATE_DISPLAY
  
# START OF ARRAY_TO_XY
# translates address offset to row/column value
# inputs: a0 (offset)
# returns: v0 (x value - 0:127), v1 (y value - 0:127) 
# registers: t1 (temp divisors), t2 (temp remainder of a0/32)
array_to_xy:
    # y = quotient of a0/32
    addi $t1, $zero, 32     # init $t1 = 32
    div $a0, $t1            # divide a0 by 32 
    mflo $v1                # v1 = y = quotient of a0 / 32
    
    # x = (remainder of a0/32) / 4
    mfhi $t2                # init $t2 = remainder of a0 / 32
    addi $t1, $zero, 4      # reassign $t1 = 4
    div $t2, $t1            # divide the remainder by 4
    mflo $v0                # v0 = x = quotient of remainder / 4
jr $ra
# END OF ARRAY_TO_XY

# START OF XY_TO_BITMAP
# translates row/column value to bitmap offset
# inputs: a0 (x value - 0:127), a1 (y value - 0:127) 
# returns: v0 (bitmap offset)
# registers: 
xy_to_bitmap:
    lw $t4, game_board_offset 
    # 128 = 2^7 so 128y = shift left by 7 bits
    sll $t3, $a1, 7             # $t3 = 128y
    add $t4, $t4, $t3           # $t4 = game_board_offset + 128y
    
    # 4 = 2^2 so 4x = shift left by 2 bits
    sll $t3, $a0, 2             # $t3 = 4x
    add $t4, $t4, $t3           # $t4 = game_board_offset + 128y + 4x 
    
    add $v0, $t4, $zero         # v0 = bitmap offset
jr $ra
# END OF XY_TO_BITMAP

# START CHECK_KEY_PRESS
# function that checks if a key was pressed
#       if a key was pressed and it is valid (w, a, s, d, q), return it's corresponding letter.
#       if a key was not pressed or if it is not a valid letter, return n (for null)
# returns: v0 (the ASCII code for a letter - w, a, s, d, q, n)
# registers: t7 (ASCII key value of key pressed), t8 (value at keyboard_address --> 0 or 1), t9 (keyboard_address)
check_key_press:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
    
    lw $t9, ADDR_KBRD               # $t9 = base keyboard address
    lw $t8, 0($t9)                  # $t8 = value at keyboard address
    beq $t8, 1, keyboard_input      # if $t8 == 1: key was pressed (ASCII key value found in next value in memory)
    
    lw $v0, n                       # otherwise, no key was pressed so set return value (v0) = n 
    j exit_check_key_press          # --> jump to exit
    
    # if a key was pressed get its ASCII value
    keyboard_input:
    lw $t7, 4($t9)                  # $t7 = ASCII key value 
    
    beq $t7, 0x61, valid_key        # a was pressed
    beq $t7, 0x64, valid_key        # d was pressed
    beq $t7, 0x77, valid_key        # w was pressed
    beq $t7, 0x73, valid_key        # s was pressed
    beq $t7, 0x71, respond_to_q     # q was pressed
    beq $t7, 0x70, respond_to_p     # p was pressed
    lw $t6, enter
    beq $t7, $t6, valid_key        # enter was pressed
    
    lw $v0, n                       # otherwise, the key pressed was invalid so set return value (v0) = n   
    j exit_check_key_press          # --> jump to exit

        valid_key:
        add $v0, $t7, $zero             # return the ASCII key value of the valid key
        j exit_check_key_press          # --> jump to exit
        
        respond_to_q:
    	li $v0, 10                      # quit gracefully
    	syscall
    	
    	respond_to_p:
    	lw $t0, current_screen             # load the current screen value into t0 
    	bne $t0, 1, skip_paused_screen     # if the current screen value != 1 (not game_screen), skip
    	jal paused_state
    	
    	skip_paused_screen:
    	lw $v0, p                       # return ascii p if the current screen is not game_screen 
        j exit_check_key_press          # --> jump to exit
	
	exit_check_key_press:
	load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
	jr $ra                           # exit the function
# END OF CHECK_KEY_PRESS

# START CALCULATE_NEXT_XY
# function that calculates the next_x and next_y position and stores the new positions in memory
#       if the given key is one of w, a, s, d, write in a new_x and new_y
#       otherwise, the given key is n new_x and new_y are assigned to curr_x and curr_y, respectively

# note: all x and y's are in relation to the GAME ARRAY setup; no return, this function mutates
# inputs: a0 (the given key; it will be one of w, a, s, d, n)
# registers: t1 (curr_x1), t2 (curr_x2), t3 (new_x1 address), t4 (new_x2 address), t5 (curr_y1), t6 (curr_y2), t7 (new_y1 address), t8 (new_y2 address) 
calculate_new_xy:
    store_registers()
    
    lw $t1, curr_x1             # t1 = curr_x1
    lw $t2, curr_x2             # t2 = curr_x2
    la $t3, new_x1              # t3 = new_x1 address
    la $t4, new_x2              # t4 = new_x2 address
    lw $t5, curr_y1             # t5 = curr_y1
    lw $t6, curr_y2             # t6 = curr_y2
    la $t7, new_y1              # t7 = new_y1 address
    la $t8, new_y2              # t8 = new_y2 address
    
    # to ensure proper calculations, set new_x, new_y as curr_x, curr_y 
    sw $t1, 0($t3)              # set new_x1 = curr_x1
    sw $t2, 0($t4)              # set new_x2 = curr_x2
    sw $t5, 0($t7)              # set new_y1 = curr_y1
    sw $t6, 0($t8)              # set new_y2 = curr_y2

    beq $a0, 0x61, shift_left                         # the given key is a
    beq $a0, 0x64, shift_right                        # the given key is d
    beq $a0, 0x77, rotate_clockwise                   # the given key is w
    beq $a0, 0x73, shift_down                         # the given key is s
    beq $a0, 0x6e, exit_calculate_next_xy             # the given key is n

    # When a is pressed, shift one unit left (only need x variables since it's a horizontal shift)
    # registers: t1 (curr_x1), t2 (curr_x2), t3 (new_x1 address), t4 (new_x2 address)
    shift_left:
        addi $t1, $t1, -1           # subtract one from curr_x1, curr_x2 to shift left
        addi $t2, $t2, -1
        
        sw $t1, 0($t3)              # store curr_x1 - 1 at new_x1 address
        sw $t2, 0($t4)              # store curr_x2 - 1 at new_x2 address
    j exit_calculate_next_xy
    
    # When d is pressed, shift one unit right (only need x variables since it's a horizontal shift)
    # registers: t1 (curr_x1), t2 (curr_x2), t3 (new_x1 address), t4 (new_x2 address)
    shift_right:
        addi $t1, $t1, 1           # add one from curr_x1, curr_x2 to shift right
        addi $t2, $t2, 1
        
        sw $t1, 0($t3)              # store curr_x1 + 1 at new_x1 address
        sw $t2, 0($t4)              # store curr_x2 + 1 at new_x2 address
    j exit_calculate_next_xy
    
    # When w is pressed, rotate one unit clockwise 
    # registers: t1 (curr_x1), t2 (curr_x2), t3 (new_x1 address), t4 (new_x2 address), t5 (curr_y1), t6 (curr_y2), t8 (new_y2 address)
    rotate_clockwise:
        beq $t5, $t6, horizontal_to_vertical        # if y1 == y2, then it is horizontal
        beq $t1, $t2, vertical_to_horizontal
        
        horizontal_to_vertical:
            blt $t1, $t2, rotate_down               # if x1 < x2, rotate x2, y2 down
            blt $t2, $t1, rotate_up                 # if x2 < x1, rotate x2, y2 up
            
            rotate_down:
                addi, $t6, $t6, 1           # curr_y2 + 1
                j exit_horz_to_vert
                
            rotate_up:
                addi, $t6, $t6, -1           # curr_y2 - 1
                j exit_horz_to_vert
            
            exit_horz_to_vert:
                sw $t6, 0($t8)              # store curr_y2 + 1 at new_y2 address
                sw $t1, 0($t4)              # store curr_x1 at new_x2 address
        j exit_calculate_next_xy
        
        vertical_to_horizontal:
            blt $t5, $t6, rotate_180               # if y2 < y1, rotate x2, y2 180 degrees (from original position where pill 1 is on the left and pill 2 is on the right)
            blt $t6, $t5, rotate_360                 # if y1 < y2, rotate x2, y2 360 degrees (from original position where pill 1 is on the left and pill 2 is on the right)
            
            rotate_180:
                addi, $t2, $t2, -1          # curr_x2 - 1
                j exit_vert_to_horz
            
            rotate_360:
                addi, $t2, $t2, 1           # curr_x2 + 1
                j exit_vert_to_horz
            
            exit_vert_to_horz:
                sw $t2, 0($t4)              # store curr_x2 - 1 at new_x2 address
                sw $t5, 0($t8)              # store curr_y1 at new_y2 address
        j exit_calculate_next_xy
    
    # When s is pressed, shift one unit down (only need y variables since it's a vertical shift)
    # registers: t5 (curr_y1), t6 (curr_y2), t7 (new_y1 address), t8 (new_y2 address)
    shift_down:
        addi $t5, $t5, 1           # add one from curr_y1, curr_y2 to shift down
        addi $t6, $t6, 1
        
        sw $t5, 0($t7)              # store curr_y1 + 1 at new_y1 address
        sw $t6, 0($t8)              # store curr_y2 + 1 at new_y2 address
    j exit_calculate_next_xy
       
    exit_calculate_next_xy:
    load_registers()
    jr $ra
# END CALCULATE_NEXT_XY

# START OF UPDATE_CAPSULE_LOCATION
# function that stores the capsule location into their respective positions in the game_array 
# registers: t0 (game_array pointer), t1 (x), t2 (y), t4 (capsuleID address), t5 (game array address), 
#            t8 (capsuleID_array pointer), t9 (temp colour), a0 (arg x for xy_to_array), a1 (arg y for xy_to_array)
update_capsule_location: 
    la $t5, game_array
    la $t4, capsuleID_array
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    # set value at curr_x1 and curr_y1
        add $t0, $t5, $zero     # t0 = game_array pointer
        
        lw $t1 curr_x1          # t1 = curr_x1
        lw $t2 curr_y1          # t2 = curr_y1
        
        add $a0, $t1, $zero     # a0 = x arg for xy_to_array
        add $a1, $t2, $zero     # a1 = y arg for xy_to_array
        jal xy_to_array         
        
        add $t0, $t0, $v0       # t0 = game_array pointer + offset
        lw $t9, colour_1        # load the first colour into t9
        sw $t9, 0($t0)          # set value at game_array[offset/4] to colour_1
        
        add $t8, $t4, $zero     # t8 = capsuleID_array pointer
        add $t8, $t8, $v0       # t8 = capsuleID_array pointer + offset
        lw $t9, capsuleID_count # load the current capsule count into t9
        sw $t9, 0($t8)          # set value at capsuleID_array pointer to capsuleID count
        
    
    # set value at curr_x2 and curr_y2
        add $t0, $t5, $zero     # t0 = game_array pointer
        
        lw $t1 curr_x2          # t1 = new_x2
        lw $t2 curr_y2          # t2 = new_y2
        
        add $a0, $t1, $zero     # a0 = x arg for xy_to_array
        add $a1, $t2, $zero     # a1 = y arg for xy_to_array
        jal xy_to_array         
        
        add $t0, $t0, $v0       # t0 = game_array pointer + offset
        lw $t9, colour_2        # load the first colour into t9
        sw $t9, 0($t0)          # set value at game_array[offset/4] to colour_2 
        
        add $t8, $t4, $zero     # t8 = capsuleID_array pointer
        add $t8, $t8, $v0       # t8 = capsuleID_array pointer + offset
        lw $t9, capsuleID_count # load the current capsule count into t9
        sw $t9, 0($t8)          # set value at capsuleID_array pointer to capsuleID count
        
        lw $ra, 0($sp)           # Load the saved value of $ra from the stack
        addi $sp, $sp, 4         # Increase the stack pointer (free up space)
        jr $ra
# END OF UPDATE_CAPSULE_LOCATION

# START OF XY_TO_ARRAY
# translates row/column value to game_array offset
# inputs: a0 (x value - 0:127), a1 (y value - 0:127) 
# returns: v0 (offset)
# registers: t9 (temp left shift)
xy_to_array:
    # offset = 32y + 4x
    add $v0, $zero, $zero       # init $v0 = offset = 0
    
    # 32 = 2^5 so 32y = shift 5 bits left
    sll $t9, $a1, 5             # $t9 = 32y
    add $v0, $v0, $t9           # $v0 = game_board_offset + 32y
    
    # 4 = 2^2 so 4x = shift 2 bits left
    sll $t9, $a0, 2             # $t9 = 4x
    add $v0, $v0, $t9           # $v0 = game_board_offset + 32y + 4x
jr $ra
# END OF ARRAY_TO_XY

# START CHECK_WALL_COLLISION
# returns: v0 (boolean; 0 if there is no collision, 1 if there is a collision) 
# registers: t1 (new_x1), t2 new_y1), t3 (new_x2), t4 (new_y2)
check_wall_collision:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    # assign t1-t4 to new_x, new_y data
    lw $t1, new_x1              # t1 = new_x1
    lw $t2, new_y1              # t2 = new_y1
    lw $t3, new_x2              # t3 = new_x2
    lw $t4, new_y2              # t4 = new_y2
    
    # check the collision with the walls 
    # new_x1 < 0 (left side of board)
    bltz $t1, wall_collision_true               # if x1 < 0, the pill hit the left side
    bltz $t3,  wall_collision_true               # if x2 < 0, the pill hit the left side
        
    # new_x1 >= 8 (right side of board)
    bge $t1, 8, wall_collision_true             # if x1 >= 8, the pill hit the right side
    bge $t3, 8, wall_collision_true             # if x2 >= 8, the pill hit the right side
        
    # new_y1 < 0 (top of board)
    bltz $t2, wall_collision_true               # if y1 < 0, the pill hit the top
    bltz $t4, wall_collision_true               # if y2 < 0, the pill hit the top
        
    # Otherwise, we know there are no collisions so set return value = 0
    add $v0, $zero, $zero
    j exit_check_wall_collision                      # return = 0 (no collision)
        
    wall_collision_true:
    addi $v0, $zero, 1                          # return = 1 (collision)
            
    exit_check_wall_collision:
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    jr $ra
# END WALL_CHECK_COLLISION

# START CHECK_OBJECT_COLLISION
# assumes that there is no wall collision (within walls)
# input: a0 (new_x), a1 (new_y)
# returns: v0 (boolean; 0 if there is no collision, 1 if there is a collision) 
# registers: t0 (game_array pointer), t1 (new_x1), t2 new_y1), t3 (new_x2), t4 (new_y2), t5 (game_array base address), t9 (value at game_array[x, y])
check_object_collision:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
    
    la $t5, game_array          # load game_array base address
    
    # assign t1-t4 to new_x, new_y data
    lw $t1, new_x1              # t1 = new_x1
    lw $t2, new_y1              # t2 = new_y1
    lw $t3, new_x2              # t3 = new_x2
    lw $t4, new_y2              # t4 = new_y2
    
    # game_array[new_x1, new_y1] is not empty
    add $a0, $t1, $zero                         # arg new_x1 for xy_to_array
    add $a1, $t2, $zero                         # arg new_y1 for xy_to_array
    jal xy_to_array             
    add $t0, $t5, $v0                           # t0 = game_array base address + offset (pointer)
    lw $t9, 0($t0)                              # load value at game_array[new_x1, new_y1]
    bne $t9, $zero, object_collision_true       # if there is value that is not 0 (black), jump to return true
    
    # game_array[new_x2, new_y2] is not empty
    add $a0, $t3, $zero                         # arg new_x1 for xy_to_array
    add $a1, $t4, $zero                         # arg new_y1 for xy_to_array
    jal xy_to_array             
    add $t0, $t5, $v0                           # t0 = game_array base address + offset (pointer)
    lw $t9, 0($t0)                              # load value at game_array[new_x1, new_y1]
    bne $t9, $zero, object_collision_true       # if there is value that is not 0 (black), jump to return true
    
    # Otherwise, we know there are no collisions so set return value = 0
    add $v0, $zero, $zero                       # return = 0 (no collision)
    j exit_check_object_collision                      
    
    object_collision_true:
    addi $v0, $zero, 1                          # return = 1 (collision)
            
    exit_check_object_collision:
    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    jr $ra
# END CHECK_OBJECT_COLLISION

# START CHECK_BOTTOM_COLLISION
# returns: v0 (boolean; 0 if there is no collision, 1 if there is a collision) 
# registers: t1 (curr_x1), t2 (curr_y1), t3 (curr_x2), t4 (curr_y2)
check_bottom_collision:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
    
    # assign t1-t4 to new_x, new_y data
    lw $t1, curr_x1              # t1 = curr_x1
    lw $t2, curr_y1              # t2 = curr_y1
    lw $t3, curr_x2              # t3 = curr_x2
    lw $t4, curr_y2              # t4 = curr_y2
    
    # new_y1 >= 15 (height of game_array)
    bge $t2, 15, bottom_collision_true          # if y1 >= 16, the pill hit the bottom
    
    # new_y2 >= 15 (height of game_array)
    bge $t4, 15, bottom_collision_true          # if y2 >= 16, the pill hit the bottom
    
    # Otherwise, we know there are no collisions so set return value = 0
    add $v0, $zero, $zero
    j exit_check_bottom_collision                      # return = 0 (no collision)
        
    bottom_collision_true:
    addi $v0, $zero, 1                          # return = 1 (collision)
            
    exit_check_bottom_collision:
    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    jr $ra
# END CHECK_BOTTOM_COLLISION

# START OF MERGE_ROW
# returns: v0 (game_array offset of the end of 4 same colours in a row or 0 if there are none)
# registers: t0 (game_array pointer), t3 (y/row count), t4 (loop unit count), t5 (game_array address), 
#            t6 (max units in a row count; from call the check_merge_row), t9 (the colour black)
merge_row:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    lw $t9, black
    
    # loop that checks each row to see if we there are at least 4 in a row, and merges if so. (starts from bottom)
    addi $t3, $zero, 15         # initialise the row count (starts from bottom, last row = 15)
    
    merge_row_loop:
        # call to check_merge_row of the current row to find out if a merge is needed. 
        add $a0, $t3, $zero                     # arg to check_merge_row; current y/row value
        jal check_merge_row
        
        la $t5, game_array
        add $t0, $t5, $v0                       # set the game_array pointer to the base address + returned offset of the last of the same colour units (-1 = no units to merge)
        add $t6, $zero, $v1                     # t6 = v1 = the number of units to merge (0 or a value >=4) 
        
        beq $t6, $zero, decrement_merge_row_loop        # if the number of units to merge is zero, go on to the next loop (check the next row)
        
        # otherwise, the number of units to merge >= 4
        # loop that changes all units in a row of the same colour to black
        add $t4, $zero, $zero                   # set the loop unit count to 0
        la $t8, capsuleID_array                 # load address of capsuleID_array into t8
        add $t8, $t8, $v0                       # set the capsuleID_array pointer to the base address + returned offset of the last of the same colour units
        jal merge_sound
        merge_row_units_loop:
            addi $t4, $t4, 1                        # increment the loop counter by 1
            
            sw $t9, 0($t0)                          # sets the value at game_array pointer to black
            addi $t0, $t0, -4                       # decreases the game_array pointer by 4 because it was initialised at the last of the same colour units
            sw $zero, 0($t8)                        # sets the value at capsuleID_array to 0
            addi $t8, $t8, -4                       # decreases the capsuleID_array pointer by 4 because it was initialised at the last of the same colour units
            
            bne $t4, $t6, merge_row_units_loop          # loops until the loop counter = the number of units to merge
        jal drop_capsule
        j merge_row_loop                            # jump to start of merge_row_loop to check the current row again for any more same colours
        
        decrement_merge_row_loop:
            addi $t3, $t3, -1                       # decrease the row number by 1
            bge $t3, 0, merge_row_loop              # loops until it hits the top row of the game

exit_merge_row:
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra

# START OF CHECK_MERGE_ROW
# inputs: a0 (y/row value)
# returns: v0 (game_array offset of the end of v1 same colours in a row or -1 if there are none), 
#          v1 (if there are >= 4 units of the same colour return that number; if there are < 4, return 0)
# registers: t0 (game_array pointer), t1 (colour count), t2 (x/column count), t5 (game_array address), t7 (current colour), t8 (next colour), t9 (the colour black)
check_merge_row:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack

    lw $t9, black               # load the colour black into t9
    la $t5, game_array          # load the game array base address into t5
    
    # need to add 32 y times
    sll $t0, $a0, 5             # multiply y by 32
    add $t0, $t0, $t5           # initialise the game_array pointer
    
    # loop that checks the row for 4 consecutive values of the same colour
    addi $t1, $zero, 1          # initialise the colour count
    lw $t7, black               # initialise the current colour
    add $t2, $zero, $zero       # reset the loop counter
    
    
    check_merge_row_loop:
        lw $t8, 0($t0)              # load the colour at the game array index into t8
        
        beq $t7, $t8, check_merge_row_loop_equals       # if the current colour and next colour are equal, jump to that condition
        
        # otherwise, we know that the next colour is different from the current colour (and is not black)
        bge $t1, 4, return_merge_row_positive       # if the colour count >= 4, jump to return
        
        add $t7, $t8, $zero                         # set current colour = next colour
        addi $t1, $zero, 1                           # reset the colour count
        j increment_check_merge_row_loop
        
        # we know that the current colour and next colour are equal. increment the colour count by 1 and check for 4 in a row.
        check_merge_row_loop_equals:
            beq $t9, $t8, check_merge_row_loop_black    # if the colour is black, jump to that condition
            addi $t1, $t1, 1                            # increment the current colour count by 1
            j increment_check_merge_row_loop
        
        # we know that the current colour is black
        check_merge_row_loop_black:
        addi $t1, $zero, 1                              # reset the colour count
        j increment_check_merge_row_loop                # next loop
        
        increment_check_merge_row_loop:
            addi $t2, $t2, 1                            # increase the loop counter by 1
            addi $t0, $t0, 4                            # add 4 to the game_array offset to check the next value
            blt $t2, 8, check_merge_row_loop            # jump to next loop if $t2 is less than 8
    
    bge $t1, 4, return_merge_row_positive
    
    # there are no four consecutive same colours
    return_merge_row_negative:
    addi $v0, $zero, -1                       # return -1 as game_array offset to indicate no merge
    add $v1, $zero, $zero                     # return zero as number of units to merge  
    j exit_check_merge_row
    
    # there are four consecutive same colours
    return_merge_row_positive:
    sub $t0, $t0, $t5                           # the game_array offset (last value)
    subi $t0, $t0, 4
    add $v0, $t0, $zero                         # returns the game_array offset
    add $v1, $t1, $zero                         # returns the number of units that are the same colour
    j exit_check_merge_row
    
    exit_check_merge_row:
    lw $ra, 0($sp)           # Load the saved value of $ra from the stackw
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF CHECK_MERGE_ROW

# START OF MERGE_COLUMN
# returns: v0 (game_array offset of the end of 4 same colours in a column or 0 if there are none)
# registers: t0 (game_array pointer), t3 (x/column count), t4 (loop unit count), t6 (max units in a column count; from call to check_merge_column), 
#            t5 (game_array address), t9 (the colour black)
merge_column:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    lw $t9, black
    
    # loop that checks each row to see if we there are at least 4 in a row, and merges if so. (starts from bottom)
    add $t3, $zero, $zero         # initialise the column count (starts from left side, first column = 0)
    
    merge_column_loop:
        # call to check_merge_column of the current column to find out if a merge is needed. 
        add $a0, $t3, $zero                     # arg to check_merge_column; current x/column value
        jal check_merge_column
        
        add $t0, $t5, $v0                       # set the game_array pointer to the base address + returned offset of the last of the same colour units (-1 = no units to merge)
        add $t6, $zero, $v1                     # t6 = v1 = the number of units to merge (0 or a value >=4) 
        
        beq $t6, $zero, decrement_merge_column_loop        # if the number of units to merge is zero, go on to the next loop (check the next column)
        
        # otherwise, the number of units to merge >= 4
        # loop that changes all units in a row of the same colour to black
        add $t4, $zero, $zero                   # set the loop unit count to 0
        la $t8, capsuleID_array                 # load address of capsuleID_array into t8
        add $t8, $t8, $v0                       # set the capsuleID_array pointer to the base address + returned offset of the last of the same colour units
        jal merge_sound
        merge_column_units_loop:
            addi $t4, $t4, 1                        # increment the loop counter by 1
            
            sw $t9, 0($t0)                          # sets the value at game_array pointer to black
            addi $t0, $t0, -32                       # decreases the game_array pointer by 32 (8 units per row * 4 bits per unit) because it was initialised at the last of the same colour units
            sw $zero, 0($t8)                        # sets the value at capsuleID_array to 0
            addi $t8, $t8, -32                      # decreases the capsuleID_array pointer by 32 because it was initialised at the last of the same colour units
            
            bne $t4, $t6, merge_column_units_loop          # loops until the loop counter = the number of units to merge
        
        add $t8, $zero, $zero                          # drop_capsule_loop loop counter 
        drop_capsule_loop:
            addi $t8, $t8, 1
            jal drop_capsule
        blt $t8, 16, drop_capsule_loop
        j merge_column_loop                            # jump to start of merge_row_loop to check the current row again for any more same colours
        
        decrement_merge_column_loop:
            addi $t3, $t3, 1                           # increase the row number by 1
            ble $t3, 7, merge_column_loop              # loops until it hits the last column in the bottle (7)

exit_merge_column:
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra

# START OF CHECK_MERGE_COLUMN
# inputs: a0 (x/column value)
# returns: v0 (game_array offset of the end of v1 same colours in a row or -1 if there are none), 
#          v1 (if there are >= 4 units of the same colour return that number; if there are < 4, return 0)
# registers: t0 (game_array pointer), t1 (colour count), t2 (x/column count), t5 (game_array address), t7 (current colour), t8 (next colour), t9 (the colour black)
check_merge_column:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()

    lw $t9, black               # load the colour black into t9
    la $t5, game_array          # load the game array base address into t5
    
    # need to multiply x by 4
    sll $t0, $a0, 2             # multiply x by 4
    add $t0, $t0, $t5         # initialise the game_array pointer
   
    # loop that checks the column for consecutive values of the same colour
    addi $t1, $zero, 1          # initialise the colour count
    lw $t7, black               # initialise the current colour
    add $t2, $zero, $zero       # reset the loop counter
    
    check_merge_column_loop:
        lw $t8, 0($t0)              # load the colour at the game array index into t8
        
        beq $t7, $t8, check_merge_column_loop_equals       # if the current colour and next colour are equal, jump to that condition
        
        # otherwise, we know that the next colour is different from the current colour 
        bge $t1, 4, return_merge_column_positive       # if the colour count >= 4, jump to return
        
        add $t7, $t8, $zero                         # set current colour = next colour
        addi $t1, $zero, 1                           # reset the colour count
        j increment_check_merge_column_loop
        
        # we know that the current colour and next colour are equal. increment the colour count by 1.
        check_merge_column_loop_equals:
            beq $t9, $t8, check_merge_column_loop_black    # if the colour is black, jump to that condition
            addi $t1, $t1, 1                                # increment the current colour count by 1
            j increment_check_merge_column_loop
        
        # we know that the current colour is black
        check_merge_column_loop_black:
            addi $t1, $zero, 1                              # reset the colour count
        j increment_check_merge_column_loop                # next loop
        
        increment_check_merge_column_loop:
            addi $t2, $t2, 1                            # increase the loop counter by 1
            addi $t0, $t0, 32                            # add 32 to the game_array offset to check the next value in the column
            blt $t2, 16, check_merge_column_loop            # jump to next loop if $t2 is less than 16
    
    bge $t1, 4, return_merge_column_positive
    
    # there are no four consecutive same colours
    return_merge_column_negative:
    addi $v0, $zero, -1                       # return -1 as game_array offset to indicate no merge
    add $v1, $zero, $zero                     # return zero as number of units to merge  
    j exit_check_merge_column
    
    # there are four consecutive same colours
    return_merge_column_positive:
    sub $t0, $t0, $t5                           # the game_array offset (last value)
    subi $t0, $t0, 32
    add $v0, $t0, $zero                         # returns the game_array offset
    add $v1, $t1, $zero                         # returns the number of units that are the same colour
    j exit_check_merge_column
    
    exit_check_merge_column:
    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF CHECK_MERGE_COLUMN

# START OF DROP_CAPSULE
# function to drop each capsule
# registers: all of them... this function is too confusing to name all the registers I used and their function
# saved registers: s0 (x loop count), s1 (y loop count), s6 (capsuleID_array address), s7 (game_array address)
drop_capsule:
subi $sp, $sp, 4
sw $ra, 0($sp)
store_registers()

la $t9, capsuleID_max       # load capsuleID_max addresss
lw $t8, capsuleID_count     # load capsuleID_count number
sw $t8, 0($t9)              # store capsuleID_count to capsuleID_max 

la $s7, game_array
la $s6, capsuleID_array

addi $s1, $zero, 15         # initialise y count (starts from second last row, last row = 15)
add $s0, $zero, $zero       # initialise x count

drop_capsule_loop_y:
addi $s1, $s1, -1
add $s0, $zero, $zero       # reset x count (column) when we reach a new y count (row) 

drop_capsule_loop_x:
    # initialise capsule info to (-1, -1) and black
    # capsule half 1
    la $t1, curr_x1
    la $t2, curr_y1
    addi $t3, $zero, -1
    sw $t3, 0($t1)
    sw $t3, 0($t2)
    
    la $t1, colour_1
    lw $t2, black
    sw $t2, 0($t1)
    
    # capsule half 2
    la $t1, curr_x2
    la $t2, curr_y2
    addi $t3, $zero, -1
    sw $t3, 0($t1)
    sw $t3, 0($t2)
    
    la $t1, colour_2
    lw $t2, black
    sw $t2, 0($t1)

    # check if current xy contains a capsule
    add $a0, $zero, $s0     # x value arg for xy_to_array
    add $a1, $zero, $s1     # y value arg for xy_to_array
    jal xy_to_array
    add $t9, $s7, $v0       # game_array pointer = base address + offset
    add $t8, $s6, $v0       # capsuleID_array pointer = base address + offset
    
    lw $t7, 0($t9)                              # colour at game_array pointer
    lw $t6, 0($t8)                              # capsuleID at capsuleID_array pointer (current unit's capsuleID)
    beq $t7, 0, increment_capsule_loop_x        # if the colour at the game_array pointer is black, go to next loop
    beq $t6, -1, increment_capsule_loop_x       # if the value at the capsuleID is -1 (virus), go to next loop
    
    # otherwise, the current unit is not black, reconstruct the capsule
    la $t1, curr_x1         # store loop x, y at curr_x1, curr_y1
    la $t2, curr_y1
    sw $s0, 0($t1)
    sw $s1, 0($t2)
    
    la $t1, colour_1        # store the colour at the pixel at colour_1
    sw $t7, 0($t1)    
    
    la $t1, capsuleID_count     # to reconstruct, store the current capsuleID from the pointer in capsuleID_count
    sw $t6, 0($t1)
    
    # Find the other half of the capsule
    beq $s0, 0, skip_check_left         # if x loop value == 0, there is no left column
    addi $t0, $t8, -4                    # check left in capsuleID_array
    lw $t1, 0($t0)                      # load value from capsuleID_array
    beq $t1, $t6, capsule_to_left      # the capsule half to the left matches the capsule ID
    
    skip_check_left:
    beq $s0, 7, skip_check_right        # if x loop value == 7, there is no right column
    addi $t0, $t8, 4                   # check right in capsuleID_array
    lw $t1, 0($t0)                      # load value from capsuleID_array
    beq $t1, $t6, capsule_to_right       # the capsule half to the right matches the capsule ID
    
    skip_check_right:
    beq $s1, 0, drop_capsule_action     # if y loop value == 0, there is no row above
    addi $t0, $t8, -32                  # check top in capsuleID_array
    lw $t1, 0($t0)                      # load value from capsuleID_array
    beq $t1, $t6, capsule_to_top       # the capsule half to the top matches the capsule ID
    
    j drop_capsule_action
    
    capsule_to_top:
    la $t1, curr_x2         # store loop x, y-1 at curr_x2, curr_y2
    la $t2, curr_y2
    addi $t3, $s1, -1       # t3 = y-1
    sw $s0, 0($t1)
    sw $t3, 0($t2)
    
    la $t1, colour_2        # store the colour at the pixel at colour_1
    lw $t7, -32($t9)        # value at game_array pointer - 32 (one row up)
    sw $t7, 0($t1)    
    j drop_capsule_action
    
    capsule_to_right:
    la $t1, curr_x2         # store loop x + 1, y at curr_x2, curr_y2
    la $t2, curr_y2
    addi $t3, $s0, 1       # t3 = x + 1
    sw $s1, 0($t2)
    sw $t3, 0($t1)
    # sw $s0, 0($t1)
    # sw $t3, 0($t2)
    
    la $t1, colour_2        # store the colour at the pixel at colour_1
    lw $t7, 4($t9)          # value at game_array pointer + 4 (one unit right)
    sw $t7, 0($t1)    
    j drop_capsule_action
    
    capsule_to_left:
    la $t1, curr_x2         # store loop x - 1, y at curr_x2, curr_y2
    la $t2, curr_y2
    addi $t3, $s0, -1       # t3 = x - 1
    sw $s1, 0($t2)          # store y from loop in curr_y2
    sw $t3, 0($t1)          # store x -1 from loop in curr_x2
    # sw $s0, 0($t1)
    # sw $t3, 0($t2)
    
    la $t1, colour_2        # store the colour at the pixel at colour_1
    lw $t7, -4($t9)         # value at game_array pointer - 4 (one unit left)
    sw $t7, 0($t1)   
    j drop_capsule_action
    
    drop_capsule_action:
    lw $t1, colour_1
    lw $t2, colour_2
    
    beq $t1, 0,  increment_capsule_loop_x        # colour 1 is black
    beq $t2, 0, move_half_capsule        # colour 2 is black but colour 1 is not
    
    # otherwise, we know neither colour_1 or colour_2 are black
    move_full_capsule:
        # calculate new_x, new_y given that the keypress is down
        addi $a0, $zero, 0x73           # dropping, so keypress = s
        jal calculate_new_xy            # after this call, new_x and new_y will contain new positions
        
        # remove the current values from the game_array and capsuleID_array
        la $t5, game_array          # load the address of the game_array
        la $t4, capsuleID_array     # load the address of the capsuleID_array
        
        # remove value of game_array[curr_x1, curr_y1] 
        lw $t7, curr_x1              # t1 = curr_x1
        lw $t8, curr_y1              # t2 = curr_y1
        add $a0, $t7, $zero          # arg x for xy_to_array
        add $a1, $t8, $zero          # arg y for xy_to_array
        jal xy_to_array
        
        add $t0, $t5, $v0           # points to game_array[curr_x1, curr_y1]
        lw $t9, black               # load the colour black
        sw $t9, 0($t0)              # put the colour black into game_array[curr_x1, curr_y1]
        
        add $t1, $t4, $v0           # points to capsuleID_array[curr_x1, curr_y1]
        sw $zero, 0($t1)            # put zero into the capsuleID_array[curr_x1, curr_y1]
        
        # remove value of game_array[curr_x2, curr_y2]
        lw $t7, curr_x2              # t1 = curr_x2
        lw $t8, curr_y2              # t2 = curr_y2
        add $a0, $t7, $zero          # arg x for xy_to_array
        add $a1, $t8, $zero          # arg y for xy_to_array
        jal xy_to_array
        add $t0, $t5, $v0           # points to game_array[curr_x2, curr_y2]
        lw $t9, black               # load the colour black
        sw $t9, 0($t0)              # put the colour black into game_array[curr_x2, curr_y2]
        add $t1, $t4, $v0           # points to capsuleID_array[curr_x1, curr_y1]
        sw $zero, 0($t1)            # put zero into the capsuleID_array[curr_x1, curr_y1]
        
        check_down_collision_drop_full:
            jal check_bottom_collision          # checks if the pill hit the bottom of the walls
            beq $v0, 1,  restore_capsule               # returns 1 if collision
            # beq $v0, 1,  increment_capsule_loop_x               # returns 1 if collision
            
            # otherwise, the pill did not hit a wall
            jal check_object_collision                          # checks if the pill hit an object
            beq $v0, 1,  restore_capsule             # returns 1 if collision
            # beq $v0, 1,  increment_capsule_loop_x             # returns 1 if collision
            
            # otherwise, we can move the pill to the new position
            # update curr_x, curr_y = new_x, new_y
            la $t1, curr_x1         # t1 = curr_x1 address
            lw $t2, new_x1          # t2 = new_x1
            sw $t2, 0($t1)          # store new_x1 at curr_x1 address
            
            la $t1, curr_y1         # t1 = curr_y1 address
            lw $t2, new_y1          # t2 = new_y1
            sw $t2, 0($t1)          # store new_y1 at curr_y1 address
            
            la $t1, curr_x2         # t1 = curr_x2 address
            lw $t2, new_x2          # t2 = new_x2
            sw $t2, 0($t1)          # store new_x2 at curr_x2 address
            
            la $t1, curr_y2         # t1 = curr_y2 address
            lw $t2, new_y2          # t2 = new_y2
            sw $t2, 0($t1)          # store new_y2 at curr_y2 address
        j restore_capsule
        # j  increment_capsule_loop_x
    
    move_half_capsule:
        jal calculate_new_xy_drop_half            # after this call, new_x and new_y will contain new positions
        
        # remove the current values from the game_array and capsuleID_array
        la $t5, game_array          # load the address of the game_array
        la $t4, capsuleID_array     # load the address of the capsuleID_array
        
        # remove value of game_array[curr_x1, curr_y1] 
        lw $t7, curr_x1              # t1 = curr_x1
        lw $t8, curr_y1              # t2 = curr_y1
        add $a0, $t7, $zero          # arg x for xy_to_array
        add $a1, $t8, $zero          # arg y for xy_to_array
        jal xy_to_array
        
        add $t0, $t5, $v0           # points to game_array[curr_x1, curr_y1]
        lw $t9, black               # load the colour black
        sw $t9, 0($t0)              # put the colour black into game_array[curr_x1, curr_y1]
        
        add $t1, $t4, $v0           # points to capsuleID_array[curr_x1, curr_y1]
        sw $zero, 0($t1)            # put zero into the capsuleID_array[curr_x1, curr_y1]
        
        check_down_collision_drop_half:
            jal check_bottom_collision_half          # checks if the pill hit the bottom of the walls
            beq $v0, 1, restore_capsule_half               # returns 1 if collision
            # beq $v0, 1, increment_capsule_loop_x               # returns 1 if collision
            
            # otherwise, the pill did not hit a wall
            jal check_object_collision_half                          # checks if the pill hit an object
            beq $v0, 1, restore_capsule_half                # returns 1 if collision
            # beq $v0, 1, increment_capsule_loop_x                # returns 1 if collision
            
            # otherwise, we can move the pill to the new position
            # update curr_x, curr_y = new_x, new_y
            la $t1, curr_x1         # t1 = curr_x1 address
            lw $t2, new_x1          # t2 = new_x1
            sw $t2, 0($t1)          # store new_x1 at curr_x1 address
            
            la $t1, curr_y1         # t1 = curr_y1 address
            lw $t2, new_y1          # t2 = new_y1
            sw $t2, 0($t1)          # store new_y1 at curr_y1 address
        
        j restore_capsule_half
        # jal update_capsule_location_half
        # j increment_capsule_loop_x
    
    restore_capsule:
    jal update_capsule_location
    j increment_capsule_loop_x
    
    restore_capsule_half:
    jal update_capsule_location_half
    j increment_capsule_loop_x
    
    increment_capsule_loop_x:
    addi $s0, $s0, 1
    # display for testing
    jal update_display
    ble $s0, 7, drop_capsule_loop_x

decrement_capsule_loop_y:
bge $s1, 1, drop_capsule_loop_y


exit_drop_capsule:
la $t9, capsuleID_count       # load capsuleID_count addresss
lw $t8, capsuleID_max        # load capsuleID_max number
sw $t8, 0($t9)              # store capsuleID_max to capsuleID_count

load_registers()
lw $ra, 0($sp)           # Load the saved value of $ra from the stack
addi $sp, $sp, 4         # Increase the stack pointer (free up space)  
# END OF DROP_CAPSULE

# START CHECK_OBJECT_COLLISION_HALF
# assumes that there is no wall collision (within walls)
# returns: v0 (boolean; 0 if there is no collision, 1 if there is a collision) 
# registers: t0 (game_array pointer), t1 (new_x1), t2 new_y1), t5 (game_array base address), t9 (value at game_array[x, y])
check_object_collision_half:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
    
    la $t5, game_array          # load game_array base address
    
    # assign t1-t4 to new_x, new_y data
    lw $t1, new_x1              # t1 = new_x1
    lw $t2, new_y1              # t2 = new_y1
    
    # game_array[new_x1, new_y1] is not empty
    add $a0, $t1, $zero                         # arg new_x1 for xy_to_array
    add $a1, $t2, $zero                         # arg new_y1 for xy_to_array
    jal xy_to_array             
    add $t0, $t5, $v0                           # t0 = game_array base address + offset (pointer)
    lw $t9, 0($t0)                              # load value at game_array[new_x1, new_y1]
    bne $t9, $zero, object_collision_half_true       # if there is value that is not 0 (black), jump to return true
    
    # Otherwise, we know there are no collisions so set return value = 0
    add $v0, $zero, $zero                       # return = 0 (no collision)
    j exit_check_object_half_collision                      
    
    object_collision_half_true:
    addi $v0, $zero, 1                          # return = 1 (collision)
            
    exit_check_object_half_collision:
    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    jr $ra
# END CHECK_OBJECT_COLLISION_HALF

# START CHECK_BOTTOM_COLLISION_HALF
# returns: v0 (boolean; 0 if there is no collision, 1 if there is a collision) 
# registers: t1 (curr_x1), t2 (curr_y1)
check_bottom_collision_half:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
    
    # assign t1-t4 to new_x, new_y data
    lw $t1, curr_x1              # t1 = curr_x1
    lw $t2, curr_y1              # t2 = curr_y1
    
    # new_y1 >= 15 (height of game_array)
    bge $t2, 15, bottom_collision_half_true          # if y1 >= 16, the pill hit the bottom
    
    # Otherwise, we know there are no collisions so set return value = 0
    add $v0, $zero, $zero
    j exit_check_bottom_collision_half                      # return = 0 (no collision)
        
    bottom_collision_half_true:
    addi $v0, $zero, 1                          # return = 1 (collision)
            
    exit_check_bottom_collision_half:
    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    
    jr $ra
# END CHECK_BOTTOM_COLLISION_HALF

# START CALCULATE_NEXT_XY_HALF
# function that calculates the next_x and next_y position and stores the new positions in memory
#       if the given key is one of w, a, s, d, write in a new_x and new_y
#       otherwise, the given key is n new_x and new_y are assigned to curr_x and curr_y, respectively

# note: all x and y's are in relation to the GAME ARRAY setup; no return, this function mutates
# inputs: a0 (the given key; it will be one of w, a, s, d, n)
# registers: t1 (curr_x1), t2 (curr_x2), t3 (new_x1 address), t4 (new_x2 address), t5 (curr_y1), t6 (curr_y2), t7 (new_y1 address), t8 (new_y2 address) 
calculate_new_xy_drop_half:
    store_registers()
    
    lw $t1, curr_x1             # t1 = curr_x1
    la $t3, new_x1              # t3 = new_x1 address
    lw $t5, curr_y1             # t5 = curr_y1
    la $t7, new_y1              # t7 = new_y1 address
    
    # to ensure proper calculations, set new_x, new_y as curr_x, curr_y 
    sw $t1, 0($t3)              # set new_x1 = curr_x1
    sw $t5, 0($t7)              # set new_y1 = curr_y1

    # shift the half, one unit down
    addi $t5, $t5, 1           # add one from curr_y1, curr_y2 to shift down
    sw $t5, 0($t7)              # store curr_y1 + 1 at new_y1 address
    
    load_registers()
    jr $ra
# END CALCULATE_NEXT_XY_HALF

# START OF UPDATE_CAPSULE_LOCATION_HALF
# function that stores the capsule location into their respective positions in the game_array 
# registers: t0 (game_array pointer), t1 (x), t2 (y), t4 (capsuleID address), t5 (game array address), 
#            t8 (capsuleID_array pointer), t9 (temp colour), a0 (arg x for xy_to_array), a1 (arg y for xy_to_array)
update_capsule_location_half: 
    la $t5, game_array
    la $t4, capsuleID_array
    
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    # set value at curr_x1 and curr_y1
        add $t0, $t5, $zero     # t0 = game_array pointer
        
        lw $t1 curr_x1          # t1 = curr_x1
        lw $t2 curr_y1          # t2 = curr_y1
        
        add $a0, $t1, $zero     # a0 = x arg for xy_to_array
        add $a1, $t2, $zero     # a1 = y arg for xy_to_array
        jal xy_to_array         
        
        add $t0, $t0, $v0       # t0 = game_array pointer + offset
        lw $t9, colour_1        # load the first colour into t9
        sw $t9, 0($t0)          # set value at game_array[offset/4] to colour_1
        
        add $t8, $t4, $zero     # t8 = capsuleID_array pointer
        add $t8, $t8, $v0       # t8 = capsuleID_array pointer + offset
        lw $t9, capsuleID_count # load the current capsule count into t9
        sw $t9, 0($t8)          # set value at capsuleID_array pointer to capsuleID count
        
        lw $ra, 0($sp)           # Load the saved value of $ra from the stack
        addi $sp, $sp, 4         # Increase the stack pointer (free up space)
        jr $ra
# END OF UPDATE_CAPSULE_LOCATION_HALF

# MODE_SCREEN AND FUNCTIONALITY
# registers used: t0 (bitmap pointer), t3 (temp number), t4 (virus_number/game_speed), t5 (current_mode address), t6 (current_mode number), t8 (enter key ascii), t9 (keypress)
mode_screen:
subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
# initialise game mode to easy

# set current screen = 0 (mode screen)
la $t0, current_screen
add $t1, $zero, $zero
sw $t1, 0($t0)

# init easy
# set number of viruses to 4
    la $t4, virus_number
    addi $t3, $zero, 4
    sw $t3, 0($t4)

# set game speed to 9 on easy mode
    la $t4, game_speed
    addi $t3, $zero, 36
    sw $t3, 0($t4)
    
# change colour to blue
    lw $t0, ADDR_DSPL
	addi $a0, $t0, 896
	lw $a1, blue
	jal draw_easy

# init med
    lw $t0, ADDR_DSPL          # initialise medium as white
    addi $a0, $t0, 1792
    lw $a1, white
    jal draw_med

# init hard
    lw $t0, ADDR_DSPL          # initialise hard as white
    addi $a0, $t0, 2688
    lw $a1, white
    jal draw_hard

    # by the end of this loop, virus_number and game_speed will be updated according to the game mode	
	mode_screen_loop:
	    la $t5, current_mode           # load the current_mode address into t5
	    lw $t6, current_mode           # load the current_mode number into t6
        
        jal check_key_press
        add $t9, $v0, $zero
        
        beq $t9, 0x73, mode_down                 # s was pressed
        lw $t8, enter
        beq $t9, $t8, exit_mode_screen_loop     # enter was pressed
        j exit_mode_screen_loop
        
        mode_down:
        addi $t6, $t6, 1                    # increase current_mode number by 1
        j change_current_mode
        
        change_current_mode:
        # initialise all the words as white
        lw $t0, ADDR_DSPL           # initialise easy as white
    	addi $a0, $t0, 896
    	lw $a1, white
    	jal draw_easy
    	
    	lw $t0, ADDR_DSPL          # initialise medium as white
    	addi $a0, $t0, 1792
    	lw $a1, white
    	jal draw_med
    	
    	lw $t0, ADDR_DSPL          # initialise hard as white
    	addi $a0, $t0, 2688
    	lw $a1, white
    	jal draw_hard
        
        # change the game mode according to the key_press
        addi $t1, $zero, 3                  # divisor is 3
        div $t6, $t1                        # Divide current_mode number by 3 to get the mod
        mfhi $t6                            # $t6 now holds the current mode number (mod 3)
        sw $t6, 0($t5)                      # store the current mode number into current_mode
        
        beq $t6, 0, game_mode_easy          # set the current game mode to easy
        beq $t6, 1, game_mode_med           # set the current game mode to medium  
        beq $t6, 2, game_mode_hard          # set the current game mode to hard 
        
        game_mode_easy:
        # set number of viruses to 4
            la $t4, virus_number
            addi $t3, $zero, 4
            sw $t3, 0($t4)
        
        # set game speed to 9 on easy mode
            la $t4, game_speed
            addi $t3, $zero, 36
            sw $t3, 0($t4)
            
        # change colour to blue
            lw $t0, ADDR_DSPL
        	addi $a0, $t0, 896
        	lw $a1, blue
        	jal draw_easy
    	j exit_mode_screen_loop
        
        game_mode_med:
        # set number of viruses to 8
            la $t4, virus_number
            addi $t3, $zero, 8
            sw $t3, 0($t4)
        
        # set game speed to 6 on medium mode
            la $t4, game_speed
            addi $t3, $zero, 24
            sw $t3, 0($t4)
            
        # change colour to blue
            lw $t0, ADDR_DSPL
        	addi $a0, $t0, 1792
        	lw $a1, blue
        	jal draw_med
    	j exit_mode_screen_loop
        
        game_mode_hard:
        # set number of viruses to 12
            la $t4, virus_number
            addi $t3, $zero, 12
            sw $t3, 0($t4)
        
        # set game speed to 3 on hard mode
            la $t4, game_speed
            addi $t3, $zero, 12
            sw $t3, 0($t4)
            
        # change colour to blue
            lw $t0, ADDR_DSPL
        	addi $a0, $t0, 2688
        	lw $a1, blue
        	jal draw_hard
    	j exit_mode_screen_loop
    	
    	exit_mode_screen_loop:
    	lw $t8, enter
        bne $t9, $t8, mode_screen_loop
        
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF MODE_SCREEN

##############################################################################################################

# START OF DRAW_EASY
# draws the word easy in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_easy:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 32            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_E
    
    add $a0, $s0, 16
	add $a1, $s1, $zero
    jal draw_A
    
    add $a0, $s0, 32
	add $a1, $s1, $zero
    jal draw_S
    
    add $a0, $s0, 48
	add $a1, $s1, $zero
    jal draw_Y
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_EASY

# START OF DRAW_MED
# draws the word MED in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_med:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 36            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero           # draw M
	add $a1, $s1, $zero
    jal draw_M
	
	addi $a0, $s0, 24           # draw E
	add $a1, $s1, $zero
    jal draw_E
    
    add $a0, $s0, 40            # draw d
	add $a1, $s1, $zero
    jal draw_D
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_MED

# START OF DRAW_HARD
# draws the word HARD in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_hard:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 32            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_H
    
    add $a0, $s0, 16
	add $a1, $s1, $zero
    jal draw_A
    
    add $a0, $s0, 32
	add $a1, $s1, $zero
    jal draw_R
    
    add $a0, $s0, 52
	add $a1, $s1, $zero
    jal draw_D
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_HARD

# START OF DRAW_A
# draws an A directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_A:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_A

# START OF DRAW_D
# draws an D directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_D:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 2 units with two spaces inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 12             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with two spaces inbetween - -
	addi $t0, $t0, 116           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 12             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with two spaces inbetween -  -
	addi $t0, $t0, 116           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 12             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 116           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer

    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_D

# START OF DRAW_E
# draws an E directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_E:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 1 unit and two spaces -  
	addi $t0, $t0, 120         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 128         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer

	# 1 unit and two spaces -  
	addi $t0, $t0, 120         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 128         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer

    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF DRAW_E

# START OF DRAW_G
# draws an G directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_G:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 4 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 1 unit
	addi $t0, $t0, 116           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - --
	addi $t0, $t0, 128           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 116           # increment t0 by 116 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 12             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
		# 3 units across ---
	addi $t0, $t0, 116           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_G

# START OF DRAW_H
# draws an H directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_H:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 2 units with a space inbetween - -
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_H

# START OF DRAW_I
# draws an I directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_I:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 1 unit in the middle - x5
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF DRAW_I

# START OF DRAW_M
# draws an M directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_M:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 5 units across -----
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - - -
	addi $t0, $t0, 112           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - - -
	addi $t0, $t0, 112           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - - -
	addi $t0, $t0, 112           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 112           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 16             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_M

# START OF DRAW_N
# draws an N directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_N:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer

	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_N

# START OF DRAW_O
# draws an O directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_O:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_O

# START OF DRAW_P
# draws an A directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_P:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 128           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_P

# START OF DRAW_R
# draws an R directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_R:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 116           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 12             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 116           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 116           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 12             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_R

# START OF DRAW_S
# draws an S directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_S:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units across ---
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 1 unit and two spaces -  
	addi $t0, $t0, 120         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 128         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer

	# two spaces and 1 unit   -  
	addi $t0, $t0, 128         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120         # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer

    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF DRAW_S

# START OF DRAW_T
# draws an T directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_T:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
    # 3 units across
    sw $t9, 0($t0)             # store the colour at the bitmap pointer
    addi $t0, $t0, 4         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	# 1 unit in the middle - x4
	addi $t0, $t0, 124         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 128         # increment t0 by 124 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF DRAW_I

# START OF DRAW_U
# draws an U directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_U:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 2 units with a space inbetween - -
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer

	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_U

# START OF DRAW_V
# draws an W directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_V:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 2 units with a space inbetween - -
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 16             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 4 units with a space inbetween -- --
	addi $t0, $t0, 112             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 8 (space in between)
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 116             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units ---
	addi $t0, $t0, 120             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 1 unit in the middle
	addi $t0, $t0, 124             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_V

# START OF DRAW_W
# draws an W directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_W:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 2 units with a space inbetween - -
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 16             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - - -
	addi $t0, $t0, 112           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - - -
	addi $t0, $t0, 112           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units with a space inbetween - - -
	addi $t0, $t0, 112           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 5 units across -----
	addi $t0, $t0, 112           # increment t0 by 120 (next row)
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	addi $t0, $t0, 4           # increment t0 by 4
	sw $t9, 0($t0)             # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_W

# START OF DRAW_Y
# draws a Y directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_Y:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 2 units with a space inbetween - -
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units with a space inbetween - -
	addi $t0, $t0, 120           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 8             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 spaces and a unit  -
	addi $t0, $t0, 128           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 3 units across ---
	addi $t0, $t0, 120           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_Y

# START OF DRAW_QUESTION_MARK
# draws a Y directly on the bitmap
# inputs: a0 (bitmap address of top left point), a1 (colour)
draw_question_mark:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	add $t9, $a1, $zero        # t9 = colour
	add $t0, $a0, $zero        # t0 = bitmap pointer
	
	# 3 units ---
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 8 (space in between)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# two spaces, 1 unit -
	addi $t0, $t0, 128           # increment t0 by start of next row (128 - 8)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# 2 units across ---
	addi $t0, $t0, 124           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	addi $t0, $t0, 4             # increment t0 by 4
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# unit in the middle
	addi $t0, $t0, 124           # increment t0 by 124 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
	# unit in the middle (dot of question mark)
	addi $t0, $t0, 256           # increment t0 by 120 (next row)
	sw $t9, 0($t0)               # store the colour at the bitmap pointer
	
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END DRAW_QUESTION_MARK

# START CLEAR_SCREEN
# registers: t0 (bitmap pointer), t1 (the loop counter), t9 (the colour black)
clear_screen: 
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
    lw $t0, ADDR_DSPL           # set the bitmap pointer (t0) to the top left corner
    lw $t9, black               # set the colour (t9) to black
    add $t1, $zero, $zero       # initialise the loop counter
    
    clear_screen_loop:
        addi $t1, $t1, 1
        sw $t9, 0($t0)
        addi $t0, $t0, 4
    blt $t1, 1024, clear_screen_loop
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END OF CLEAR_SCREEN

# START CHECK_WIN
# returns 0 if all viruses are not gone, and 1 if all virsues are gone
# registers: t0 (capsuleID_array pointer), t1 (value at t0), t8 (loop counter), t9 (the colour black)
check_win:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    
	la $t0, capsuleID_array         # load the capsuleID_array address
	add $t8, $zero, $zero           # initialise the loop counter
	
	check_win_loop:
    	addi $t8, $t8, 1                # increment loop counter by 1
    	
    	lw $t1, 0($t0)                     # load the value at the capsuleID_array pointer into t1
    	beq $t1, -1, check_win_negative    # if the value is a -1 (indicating virus), jump to return 0
    	
    	addi $t0, $t0, 4                # point capsuleID_array pointer to next address in array
    	blt $t8, 128, check_win_loop    # breaks after all values in capsuleID_array have been checked
    
    j check_win_positive                # otherwise, we have looped through all values and have not found any remaining viruses, return 1            
    
    check_win_positive:                 # return 1
    addi $v0, $zero, 1
	j exit_check_win
    
	check_win_negative:                # return 0
	add $v0, $zero, $zero
	j exit_check_win
	
	exit_check_win:
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
    jr $ra
# END CHECK_WIN

# START OF DRAW_GAME
# draws the word game in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_game:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 28            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_G
    
    add $a0, $s0, 20
	add $a1, $s1, $zero
    jal draw_A
    
    add $a0, $s0, 36
	add $a1, $s1, $zero
    jal draw_M
    
    add $a0, $s0, 60
	add $a1, $s1, $zero
    jal draw_E
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_GAME

# START OF DRAW_OVER
# draws the word game in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_over:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 28            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_O
    
    add $a0, $s0, 16
	add $a1, $s1, $zero
    jal draw_V
    
    add $a0, $s0, 40    
	add $a1, $s1, $zero
    jal draw_E
    
    add $a0, $s0, 56
	add $a1, $s1, $zero
    jal draw_R
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_OVER

# START OF DRAW_RETRY
# draws the word retry in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_retry:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 16            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_R
	
	add $a0, $s0, 20
	add $a1, $s1, $zero
    jal draw_E
    
    add $a0, $s0, 36
	add $a1, $s1, $zero
    jal draw_T
    
    add $a0, $s0, 52
	add $a1, $s1, $zero
    jal draw_R
    
    add $a0, $s0, 72
	add $a1, $s1, $zero
    jal draw_Y
    
    add $a0, $s0, 88
	add $a1, $s1, $zero
    jal draw_question_mark
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_RETRY

# START OF DRAW_YOU
# draws the word you in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_you:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    addi $s0, $a0, 44            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
    
    add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_Y
    
    addi $a0, $s0, 16
	add $a1, $s1, $zero
    jal draw_O
    
    addi $a0, $s0, 32
	add $a1, $s1, $zero
    jal draw_U
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_YOU

# START OF DRAW_WIN
# draws the word win in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_win:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    addi $s0, $a0, 44            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
    
    add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_W
    
    addi $a0, $s0, 24
	add $a1, $s1, $zero
    jal draw_I
    
    addi $a0, $s0, 32
	add $a1, $s1, $zero
    jal draw_N
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_WIN

# GAME_OVER_SCREEN AND FUNCTIONALITY
# inputs: a0 (win (1) or lose (0))
# registers used: t0 (bitmap pointer), t3 (temp number), t4 (virus_number/game_speed), t5 (current_mode address), t6 (current_mode number), t8 (enter key ascii), t9 (keypress)
game_over_screen:
# set current screen = 2 (game over screen)
la $t0, current_screen
addi $t1, $zero, 2
sw $t1, 0($t0)
    
jal clear_screen                # clear the screen
beq $a0, 0, draw_game_over      # if the user lost, draw game over
beq $a0, 1, draw_you_win        # if the user won, draw you win

draw_you_win:               # draw you win on the screen
    lw $t0, ADDR_DSPL
	addi $a0, $t0, 768
	lw $a1, white
	jal draw_you
	
	lw $t0, ADDR_DSPL         
    addi $a0, $t0, 1664
    lw $a1, white
    jal draw_win
    
    jal win_sound
	
	j check_retry

draw_game_over:             # draw game over on the screen
    lw $t0, ADDR_DSPL
	addi $a0, $t0, 768
	lw $a1, white
	jal draw_game

    lw $t0, ADDR_DSPL          
    addi $a0, $t0, 1664
    lw $a1, white
    jal draw_over
    jal lose_sound
    j check_retry

check_retry:
    lw $t0, ADDR_DSPL          # draw retry on the screen
    addi $a0, $t0, 2816
    lw $a1, blue
    jal draw_retry
    
    check_retry_loop:           # checks for keypress = r, so we know to reset the game
    jal check_key_press         # otherwise, quit
    add $t9, $v0, $zero
    lw $t8, enter
    
    li $v0, 32
	li $a0, 100
	syscall
    bne $t9, $t8, check_retry_loop
    
    # we know that outside this loop, the user pressed r because q quits.
    jal reset_game
    jal clear_screen
    j main
# END GAME_OVER_SCREEN

# START OF RESET_GAME
# reset game function
reset_game:
subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
# reset mode to 0 (easy)
    la $t0, current_mode
    sw $zero, 0($t0)
# reset capsuleID_count to zero
    la $t0, capsuleID_count     
    sw $zero, 0($t0)

# reset game_array to all black
    la $t0, game_array           # set the bitmap pointer (t0) to the top left corner
    lw $t9, black               # set the colour (t9) to black
    add $t1, $zero, $zero       # initialise the loop counter
        
    clear_game_array_loop:
        addi $t1, $t1, 1
        sw $t9, 0($t0)
        addi $t0, $t0, 4
    blt $t1, 128, clear_game_array_loop

# reset capsuleID_array to all 0s
la $t0, capsuleID_array           # set the bitmap pointer (t0) to the top left corner
add $t9, $zero, $zero             # set the colour (t9) to black
add $t1, $zero, $zero             # initialise the loop counter

clear_capsuleID_array_loop:
    addi $t1, $t1, 1
    sw $t9, 0($t0)
    addi $t0, $t0, 4
blt $t1, 128, clear_capsuleID_array_loop

lw $ra, 0($sp)           # Load the saved value of $ra from the stack
addi $sp, $sp, 4         # Increase the stack pointer (free up space)	
jr $ra
# END OF RESET_GAME

# START OF DRAW_PAUSED
# draws the word paused in the centre of the top row of the bitmap
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
draw_paused:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    
    add $s0, $a0, 16            # s0 = add 32 to row/y value for centring
	add $s1, $a1, $zero         # s1 = colour
	
	add $a0, $s0, $zero
	add $a1, $s1, $zero
    jal draw_P
	
	add $a0, $s0, 16
	add $a1, $s1, $zero
    jal draw_A
    
    add $a0, $s0, 32
	add $a1, $s1, $zero
    jal draw_U
    
    add $a0, $s0, 48
	add $a1, $s1, $zero
    jal draw_S
    
    add $a0, $s0, 64
	add $a1, $s1, $zero
    jal draw_E
    
    add $a0, $s0, 80
	add $a1, $s1, $zero
    jal draw_D
    
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END DRAW_PAUSED

# START OF PAUSED_STATE
# pauses the game until the user presses p again
paused_state:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    store_registers()
    
    lw $a0, ADDR_DSPL           # set the argument for row number to the 2nd row (bitmap address + 128)
    addi $a0, $a0, 128
    lw $a1, white               # set the colour argument to be white
    
    la $t0, current_screen
    addi $t1, $zero, 3          # store the number 4 (paused_screen) at current_screen
    sw $t1, 0($t0)
    
    jal draw_paused

    # check for keypress = p or else quit
    paused_state_loop:
        jal check_key_press             # check for key press
        add $t9, $v0, $zero             # load key press ascii into t9  
        lw $t8, p                       # load the ascii for p into t8   
        
        li $v0, 32
    	li $a0, 100
    	syscall
        bne $t9, $t8, paused_state_loop      # loop until p is pressed again
    
    # we know that outside this loop, the user pressed p
    lw $a0, ADDR_DSPL           # set the argument for row number to the 2nd row (bitmap address + 128)
    addi $a0, $a0, 128
    lw $a1, black               # set the colour argument to be white
    
    jal draw_paused
    
    la $t0, current_screen
    addi $t1, $zero, 1          # store the number 1 (game_screen) at current_screen
    sw $t1, 0($t0)
    
    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF PAUSED STATE 

# START OF DISPLAY_NEXT_PILL
# displays the next pill colours to the right of the bottle
# inputs: a0 (bitmap address of top row/y value), a1 (colour)
display_next_pill:
    subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack 
    store_registers()

    lw $t5, ADDR_DSPL

    lw $t9, next_pill_colour1
    addi $t5, $t5, 2276
    sw $t9, 0($t5)
    
    lw $t8, next_pill_colour2
    addi $t5, $t5, 4
    sw $t8, 0($t5)

    load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END OF DISPLAY_NEXT_PILL

# START SHIFT_SOUND
shift_sound:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
	store_registers()
	
	li $v0, 31
    li $a0, 75 # pitch
    li $a1, 250 # duration
    li $a2, 115 # instrument
    li $a3, 100 # volume
    syscall
	
	exit_shift_sound:
	load_registers()
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END SHIFT_SOUND

# START ROTATE_SOUND
rotate_sound:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
	
	li $v0, 31
    li $a0, 80 # pitch
    li $a1, 250 # duration
    li $a2, 118 # instrument
    li $a3, 100 # volume
    syscall
	
	exit_rotate_sound:
	load_registers()
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END rotate_SOUND

# START COLLIDE_SOUND
collide_sound:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
	
	li $v0, 31
    li $a0, 25 # pitch
    li $a1, 250 # duration
    li $a2, 115 # instrument
    li $a3, 100 # volume
    syscall
	
	exit_collide_sound:
	load_registers()
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END COLLIDE_SOUND

# START MERGE_SOUND
merge_sound:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
	
	li $v0, 31
    li $a0, 82 # pitch
    li $a1, 300 # duration
    li $a2, 10 # instrument
    li $a3, 100 # volume
    syscall
	
	exit_merge_sound:
	load_registers()
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END CLICK_SOUND

# START LOSE_SOUND
lose_sound:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
	
	li $t1, 74
    
    li $v0, 32
	li $a0, 500
	syscall
    
    li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 57 # instrument
    li $a3, 100 # volume
    syscall
    
    # li $v0, 32
	# li $a0, 500
	# syscall
	
	addi $t1, $t1, -1
	
	li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 57 # instrument
    li $a3, 100 # volume
    syscall
    
    # li $v0, 32
	# li $a0, 500
	# syscall
	
	addi $t1, $t1, -1
	
	li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 57 # instrument
    li $a3, 100 # volume
    syscall
    
    # li $v0, 32
	# li $a0, 500
	# syscall
	
	addi $t1, $t1, -1
	
	li $v0, 31
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 57 # instrument
    li $a3, 100 # volume
    syscall
	
	exit_lose_sound:
	load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END LOSE_SOUND

# START WIN_SOUND
win_sound:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
	
	li $t1, 80
	
	li $v0, 32
	li $a0, 500
	syscall
	
	li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 10 # instrument
    li $a3, 100 # volume
    syscall
	
	addi $t1, $t1, 4
	
	li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 10 # instrument
    li $a3, 100 # volume
    syscall
    
	addi $t1, $t1, 3
	
	li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 10 # instrument
    li $a3, 100 # volume
    syscall
    
	addi $t1, $t1, 5
	
	li $v0, 33
    add $a0, $t1, $zero # pitch
    li $a1, 400 # duration
    li $a2, 10 # instrument
    li $a3, 100 # volume
    syscall
	
	exit_win_sound:
	load_registers()
	lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END WIN_SOUND

# START PLAY_MUSIC_NOTE
# registers: s0 (music_sleep_count value), s1 (times address), s2 (notes address), s3 (velocity address), s4 (duration address), 
#            t0 (music_sleep_count address/music_array_offset address), t1 (times address + music array offset), t2 (notes address + music array offset), 
#            t3 (velocity address + music array offset), t4 (duration address + music array offset)), t5 (music_array_offset), 
#            t6 (value of t1), t7 (value of t2), t8 (value of t3), t9 (value of t4)
play_music_note:
	subi $sp, $sp, 4            # Decrease stack pointer (make space for a word)
    sw $ra, 0($sp)              # Store the value of $ra at the top of the stack
    store_registers()
    
    lw $s0, music_sleep_count   # load the value of music_sleep_count into t0
    
    la $s1, times               # load address of times array into s1
    la $s2, notes               # load address of notes array into s2
    la $s3, velocity            # load address of velocity (volume) array into s3
    la $s4, duration            # load address of duration array into s4
    
    lw $t5, music_array_offset      # load music_array_offset value into t5
	
    add $t1, $s1, $t5                       # add music_array_offset to times address
    lw $t6, 0($t1)                          # load the time value at times address + music_array_offset
    bne $t6, $s0, exit_play_music_note      # if time value != music_sleep_count, exit 
    
    # otherwise, we know time value == music_sleep_count, so play notes
    play_note_loop:
        lw $t5, music_array_offset      # load music_array_offset value into t5
        add $t1, $s1, $t5               # add music_array_offset to times address    (t1)
        add $t2, $s2, $t5               # add music_array_offset to notes address    (t2)
        add $t3, $s3, $t5               # add music_array_offset to velocity address (t3)  
        add $t4, $s4, $t5               # add music_array_offset to duration address (t4)
        
        lw $t7, 0($t2)                  # load the note into t7
        lw $t8, 0($t3)                  # load the velocity (volume) into t8
        lw $t9, 0($t4)                  # load the duration into t9
    
    	li $v0, 31
        add $a0, $t7, $zero             # pitch
        add $a1, $t9, $zero             # duration
        li $a2, 80                      # instrument
        add $a3, $t8, $zero             # volume
        syscall
        
        blt $t5, 9040, play_note_loop_condition     # if music_array_offset < 9044 (end of array), loop again
        
        # otherwise, we know music_array_offset >= 9044 so reset music_array_offset and music_sleep_count to 0 then exit the loop
        la $t0, music_array_offset        # load the address of music_array_offset
        sw $zero, 0($t0)                  # reset music_array_offset to 0
        
        la $t0, music_sleep_count         # load the address of music_sleep_count
        li $t9, -25
        sw $t9, 0($t0)                  # reset music_sleep_count to 0
        
        j exit_play_music_note
	    
	    play_note_loop_condition:
    	    la $t0, music_array_offset      # load the address of music_array_offset
            addi $t5, $t5, 4                # increment the music_array_offset by 4 (to get to next value in music arrays)
            sw $t5, 0($t0)                  # store the incremented value in music_array_offset
            
            add $t1, $s1, $t5                       # add music_array_offset to times address (t1)
            lw $t6, 0($t1)                          # load the time value at times address + music_array_offset into t6
            beq $t6, $s0, play_note_loop      # if time value (t6) == music_sleep_count, keep looping 
	    
	exit_play_music_note:
	load_registers()
    lw $ra, 0($sp)           # Load the saved value of $ra from the stack
    addi $sp, $sp, 4         # Increase the stack pointer (free up space)
    jr $ra
# END PLAY_MUSIC_NOTE
